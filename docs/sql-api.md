# SQL API
<!-- Note: This document is autogenerated. DO NOT EDIT. -->
## Functions
### prom_api.add_prom_node

```
procedure void **prom_api.add_prom_node**(IN node_name text, IN attach_to_existing_metrics boolean DEFAULT true)
```
### prom_api.config_maintenance_jobs
Configure the number of maintenance jobs run by the job scheduler, as well as their scheduled interval. Sets identical settings for all job types.
```
function boolean **prom_api.config_maintenance_jobs**(number_jobs integer, new_schedule_interval interval, new_config jsonb DEFAULT NULL::jsonb)
```
### prom_api.config_maintenance_jobs
Configure the number of maintenance jobs run by the job scheduler, as well as their scheduled interval
```
function boolean **prom_api.config_maintenance_jobs**(signal _ps_catalog.signal_type, job_type _ps_catalog.job_type, number_jobs integer, new_schedule_interval interval, new_config jsonb DEFAULT NULL::jsonb)
```
### prom_api.drop_metric

```
function void **prom_api.drop_metric**(metric_name_to_be_dropped text)
```
### prom_api.eq
returns true if the labels and jsonb are equal, ignoring the metric name
```
function boolean **prom_api.eq**(labels label_array, json_labels jsonb)
```
### prom_api.eq
returns true if two label arrays are equal, ignoring the metric name
```
function boolean **prom_api.eq**(labels1 label_array, labels2 label_array)
```
### prom_api.eq
returns true if the label array and matchers are equal, there should not be a matcher for the metric name
```
function boolean **prom_api.eq**(labels1 label_array, matchers matcher_positive)
```
### prom_api.execute_maintenance
Execute maintenance tasks like dropping data according to retention policy.
 This function exists for backwards compatiblity and executes all types of jobs except trace compression at once
```
procedure void **prom_api.execute_maintenance**(IN log_verbose boolean DEFAULT false)
```
### prom_api.execute_maintenance
Executes a specified maintenance job type like dropping data according to retention policy. This procedure should be run regularly in a cron job
```
procedure void **prom_api.execute_maintenance**(IN signal _ps_catalog.signal_type, IN job_type _ps_catalog.job_type, IN log_verbose boolean DEFAULT false)
```
### prom_api.get_default_chunk_interval
Get the default chunk interval for all metrics
```
function interval **prom_api.get_default_chunk_interval**()
```
### prom_api.get_default_metric_retention_period
get the default retention period for all metrics
```
function interval **prom_api.get_default_metric_retention_period**()
```
### prom_api.get_downsample_old_data

```
function boolean **prom_api.get_downsample_old_data**()
```
### prom_api.get_downsampling_state
Get automatic downsample state
```
function boolean **prom_api.get_downsampling_state**()
```
### prom_api.get_metric_chunk_interval
Get the chunk interval for a specific metric, or the default chunk interval if not explicitly set
```
function interval **prom_api.get_metric_chunk_interval**(metric_name text)
```
### prom_api.get_metric_metadata

```
function TABLE(metric_family text, type text, unit text, help text) **prom_api.get_metric_metadata**(metric_family_name text)
```
### prom_api.get_metric_retention_period
get the retention period for a specific metric
```
function interval **prom_api.get_metric_retention_period**(metric_name text)
```
### prom_api.get_metric_retention_period
get the retention period for a specific metric
```
function interval **prom_api.get_metric_retention_period**(metric_schema text, metric_name text)
```
### prom_api.get_multiple_metric_metadata

```
function TABLE(metric_family text, type text, unit text, help text) **prom_api.get_multiple_metric_metadata**(metric_families text[])
```
### prom_api.is_normal_nan
returns true if the value is a NaN
```
function boolean **prom_api.is_normal_nan**(value double precision)
```
### prom_api.is_stale_marker
returns true if the value is a Prometheus stale marker
```
function boolean **prom_api.is_stale_marker**(value double precision)
```
### prom_api.jsonb
converts a labels array to a JSONB object
```
function jsonb **prom_api.jsonb**(labels label_array)
```
### prom_api.key_value_array
converts a labels array to two arrays: one for keys and another for values
```
function record **prom_api.key_value_array**(labels label_array, OUT keys text[], OUT vals text[])
```
### prom_api.label_cardinality

```
function integer **prom_api.label_cardinality**(label_id integer)
```
### prom_api.label_key_position

```
function integer **prom_api.label_key_position**(metric_name text, key text)
```
### prom_api.labels
fetches labels array for the given series id
```
function label_array **prom_api.labels**(series_id bigint)
```
### prom_api.labels_info
converts an array of label ids to three arrays: one for ids, one for keys and another for values
```
function record **prom_api.labels_info**(INOUT labels integer[], OUT keys text[], OUT vals text[])
```
### prom_api.matcher
returns a matcher for the JSONB, __name__ is ignored. The matcher can be used to match against a label array using @> or ? operators
```
function matcher_positive **prom_api.matcher**(labels jsonb)
```
### prom_api.promscale_post_restore
Performs required setup tasks after restoring the database from a logical backup
```
function void **prom_api.promscale_post_restore**()
```
### prom_api.register_metric_view

```
function boolean **prom_api.register_metric_view**(schema_name text, view_name text, refresh_interval interval, if_not_exists boolean DEFAULT false, downsample_id bigint DEFAULT NULL::bigint)
```
### prom_api.reset_metric_chunk_interval
resets the chunk interval for a specific metric to using the default
```
function boolean **prom_api.reset_metric_chunk_interval**(metric_name text)
```
### prom_api.reset_metric_compression_setting
resets the compression setting for a specific metric to using the default
```
function boolean **prom_api.reset_metric_compression_setting**(metric_name text)
```
### prom_api.reset_metric_retention_period
resets the retention period for a specific raw metric in the default schema to using the default retention period
```
function boolean **prom_api.reset_metric_retention_period**(metric_name text)
```
### prom_api.reset_metric_retention_period
resets the retention period for a specific metric to using the default
```
function boolean **prom_api.reset_metric_retention_period**(schema_name text, metric_name text)
```
### prom_api.set_compression_on_metric_table
set a compression for a specific metric table
```
function void **prom_api.set_compression_on_metric_table**(metric_table_name text, compression_setting boolean)
```
### prom_api.set_default_chunk_interval
set the chunk interval for any metrics (existing and new) without an explicit override
```
function boolean **prom_api.set_default_chunk_interval**(chunk_interval interval)
```
### prom_api.set_default_compression_setting
set the compression setting for any metrics (existing and new) without an explicit override
```
function boolean **prom_api.set_default_compression_setting**(compression_setting boolean)
```
### prom_api.set_default_retention_period
set the retention period for any metrics (existing and new) without an explicit override
```
function boolean **prom_api.set_default_retention_period**(retention_period interval)
```
### prom_api.set_downsample_old_data

```
function void **prom_api.set_downsample_old_data**(_state boolean)
```
### prom_api.set_downsampling_state
Set automatic-downsampling state for metrics. Downsampled data will be created only if this returns true
```
function void **prom_api.set_downsampling_state**(_state boolean)
```
### prom_api.set_metric_chunk_interval
set a chunk interval for a specific metric (this overrides the default)
```
function boolean **prom_api.set_metric_chunk_interval**(metric_name text, chunk_interval interval)
```
### prom_api.set_metric_compression_setting
set a compression setting for a specific metric (this overrides the default)
```
function boolean **prom_api.set_metric_compression_setting**(metric_name text, new_compression_setting boolean)
```
### prom_api.set_metric_retention_period
set a retention period for a specific raw metric in default schema (this overrides the default)
```
function boolean **prom_api.set_metric_retention_period**(metric_name text, new_retention_period interval)
```
### prom_api.set_metric_retention_period
set a retention period for a specific metric (this overrides the default)
```
function boolean **prom_api.set_metric_retention_period**(schema_name text, metric_name text, new_retention_period interval)
```
### prom_api.unregister_metric_view

```
function boolean **prom_api.unregister_metric_view**(schema_name text, view_name text, if_exists boolean DEFAULT false)
```
### prom_api.val
returns the label value from a label id
```
function text **prom_api.val**(label_id integer)
```
### ps_tag.tag_op_equals
This function supports the == operator.
```
function tag_op_equals **ps_tag.tag_op_equals**(_tag_key text, _value anyelement)
```
### ps_tag.tag_op_equals_text
This function supports the == operator.
```
function tag_op_equals **ps_tag.tag_op_equals_text**(_tag_key text, _value text)
```
### ps_tag.tag_op_greater_than
This function supports the #> operator.
```
function tag_op_greater_than **ps_tag.tag_op_greater_than**(_tag_key text, _value anyelement)
```
### ps_tag.tag_op_greater_than_or_equal
This function supports the #>= operator.
```
function tag_op_greater_than_or_equal **ps_tag.tag_op_greater_than_or_equal**(_tag_key text, _value anyelement)
```
### ps_tag.tag_op_greater_than_or_equal_text
This function supports the #>= operator.
```
function tag_op_greater_than_or_equal **ps_tag.tag_op_greater_than_or_equal_text**(_tag_key text, _value text)
```
### ps_tag.tag_op_greater_than_text
This function supports the #> operator.
```
function tag_op_greater_than **ps_tag.tag_op_greater_than_text**(_tag_key text, _value text)
```
### ps_tag.tag_op_jsonb_path_exists
This function supports the @? operator.
```
function tag_op_jsonb_path_exists **ps_tag.tag_op_jsonb_path_exists**(_tag_key text, _value jsonpath)
```
### ps_tag.tag_op_less_than
This function supports the #< operator.
```
function tag_op_less_than **ps_tag.tag_op_less_than**(_tag_key text, _value anyelement)
```
### ps_tag.tag_op_less_than_or_equal
This function supports the #<= operator.
```
function tag_op_less_than_or_equal **ps_tag.tag_op_less_than_or_equal**(_tag_key text, _value anyelement)
```
### ps_tag.tag_op_less_than_or_equal_text
This function supports the #<= operator.
```
function tag_op_less_than_or_equal **ps_tag.tag_op_less_than_or_equal_text**(_tag_key text, _value text)
```
### ps_tag.tag_op_less_than_text
This function supports the #< operator.
```
function tag_op_less_than **ps_tag.tag_op_less_than_text**(_tag_key text, _value text)
```
### ps_tag.tag_op_not_equals
This function supports the !== operator.
```
function tag_op_not_equals **ps_tag.tag_op_not_equals**(_tag_key text, _value anyelement)
```
### ps_tag.tag_op_not_equals_text
This function supports the !== operator.
```
function tag_op_not_equals **ps_tag.tag_op_not_equals_text**(_tag_key text, _value text)
```
### ps_tag.tag_op_regexp_matches
This function supports the ==~ operator.
```
function tag_op_regexp_matches **ps_tag.tag_op_regexp_matches**(_tag_key text, _value text)
```
### ps_tag.tag_op_regexp_not_matches
This function supports the !=~ operator.
```
function tag_op_regexp_not_matches **ps_tag.tag_op_regexp_not_matches**(_tag_key text, _value text)
```
### ps_trace.delete_all_traces
WARNING: this function deletes all spans and related tracing data in the system and restores
it to a "just installed" state.
```
function void **ps_trace.delete_all_traces**()
```
### ps_trace.downstream_spans
For a given trace_id and span_id this function returns a set that consists of the all spans starting
from the specified span and down to the leaves of the trace. Each span is annotated with parent_span_id,
a distance from the specified span (the span itself has the distance of 0) and a path from the specified span 
towards the root. Optional third argument allows to limit the span tree traversal to a certain distance from 
the specified span_id.
```
function TABLE(trace_id trace_id, parent_span_id bigint, span_id bigint, dist integer, path bigint[]) **ps_trace.downstream_spans**(_trace_id trace_id, _span_id bigint, _max_dist integer DEFAULT NULL::integer)
```
### ps_trace.event_tag_type
This function returns tag_type with the event tag bit set.
```
function tag_type **ps_trace.event_tag_type**()
```
### ps_trace.get_tag_map
For a given jsonb object consisting of key-value pairs, representing tags and their values,
this function returns a jsonb object of corresponding ids -- the primary keys in
_ps_trace.tag_key and _ps_trace.tag tables.
```
function tag_map **ps_trace.get_tag_map**(_tags jsonb)
```
### ps_trace.get_trace_retention_period
get the retention period for trace data
```
function interval **ps_trace.get_trace_retention_period**()
```
### ps_trace.is_event_tag_type
This function checks whether a tag_type value has the event tag bit set.
```
function boolean **ps_trace.is_event_tag_type**(_tag_type tag_type)
```
### ps_trace.is_link_tag_type
This function checks whether a tag_type value has the link tag bit set.
```
function boolean **ps_trace.is_link_tag_type**(_tag_type tag_type)
```
### ps_trace.is_resource_tag_type
This function checks whether a tag_type value has the resource tag bit set.
```
function boolean **ps_trace.is_resource_tag_type**(_tag_type tag_type)
```
### ps_trace.is_span_tag_type
This function checks whether a tag_type value has the span tag bit set.
```
function boolean **ps_trace.is_span_tag_type**(_tag_type tag_type)
```
### ps_trace.link_tag_type
This function returns tag_type with the link tag bit set.
```
function tag_type **ps_trace.link_tag_type**()
```
### ps_trace.operation_calls
This function counts the number of parent -> child pairs (aka calls) within a specified
time window and their operation ids.
```
function TABLE(parent_operation_id bigint, child_operation_id bigint, cnt bigint) **ps_trace.operation_calls**(_start_time_min timestamp with time zone, _start_time_max timestamp with time zone)
```
### ps_trace.put_instrumentation_lib
This function creates an entry in the _ps_trace.instrumentation_lib table if it doesn't exit and returns its id.
It is meant to be used during span creation, to obtain a valid value for mandatory instrumentation_lib_id attribute.
```
function bigint **ps_trace.put_instrumentation_lib**(_name text, _version text, _schema_url_id bigint)
```
### ps_trace.put_operation
This function creates an operation record and a necessary service.name tag, if either doesn't exist 
and returns the operation's id (a key in the _ps_tag.opertaions table). It is meant to be used during
span creation, to obtain a valid value for mandatory operation_id attribute.
```
function bigint **ps_trace.put_operation**(_service_name text, _span_name text, _span_kind span_kind)
```
### ps_trace.put_schema_url
This function creates an entry in the _ps_trace.schema_url table if it doesn't exit and returns its id.
It is meant to be used during span creation, to obtain a valid value for mandatory resource_schema_url_id attribute.
```
function bigint **ps_trace.put_schema_url**(_schema_url text)
```
### ps_trace.put_tag
This function inserts a new tag with the specified value and returns its id (a key in _ps_trace.tag table).
The specified tag key must exist for the specified resource type.
```
function bigint **ps_trace.put_tag**(_key tag_k, _value _ps_trace.tag_v, _tag_type tag_type)
```
### ps_trace.put_tag_key
This function creates a new tag key and associates it with the specified tag type and returns
its id (a key in _ps_trace.tag_key table)
```
function bigint **ps_trace.put_tag_key**(_key tag_k, _tag_type tag_type)
```
### ps_trace.resource_tag_type
This function returns tag_type with the resource tag bit set.
```
function tag_type **ps_trace.resource_tag_type**()
```
### ps_trace.set_trace_retention_period
set the retention period for trace data
```
function boolean **ps_trace.set_trace_retention_period**(_trace_retention_period interval)
```
### ps_trace.sibling_spans
For a given trace_id and span_id this function returns spans sharing the same parent_span_id.
```
function TABLE(trace_id trace_id, parent_span_id bigint, span_id bigint) **ps_trace.sibling_spans**(_trace_id trace_id, _span_id bigint)
```
### ps_trace.span_tag_type
This function returns tag_type with the span tag bit set.
```
function tag_type **ps_trace.span_tag_type**()
```
### ps_trace.span_tree
For a given pair of trace_id and span_id, this function returns a union of
downstream_spans and upstream_spans.
```
function TABLE(trace_id trace_id, parent_span_id bigint, span_id bigint, dist integer, is_upstream boolean, is_downstream boolean, path bigint[]) **ps_trace.span_tree**(_trace_id trace_id, _span_id bigint, _max_dist integer DEFAULT NULL::integer)
```
### ps_trace.tag_map_in
This function is a part of custom ps_trace.tag_map type which is a wrapper for the built-in jsonb. It is the same as its jsonb_ namesake.
```
function tag_map **ps_trace.tag_map_in**(cstring)
```
### ps_trace.tag_map_object_field
This function is a part of custom ps_trace.tag_map type which is a wrapper for
the built-in jsonb. It is the same as its jsonb_ namesake, but returns _ps_trace.tag_v.
```
function _ps_trace.tag_v **ps_trace.tag_map_object_field**(tag_map, text)
```
### ps_trace.tag_map_out
This function is a part of custom ps_trace.tag_map type which is a wrapper for the built-in jsonb. It is the same as its jsonb_ namesake.
```
function cstring **ps_trace.tag_map_out**(tag_map)
```
### ps_trace.tag_map_recv
This function is a part of custom ps_trace.tag_map type which is a wrapper for the built-in jsonb. It is the same as its jsonb_ namesake.
```
function tag_map **ps_trace.tag_map_recv**(internal)
```
### ps_trace.tag_map_send
This function is a part of custom ps_trace.tag_map type which is a wrapper for the built-in jsonb. It is the same as its jsonb_ namesake.
```
function bytea **ps_trace.tag_map_send**(tag_map)
```
### ps_trace.tag_map_subscript_handler
This function is a part of custom ps_trace.tag_map type which is a wrapper for the built-in jsonb. It is the same as its jsonb_ namesake.
```
function internal **ps_trace.tag_map_subscript_handler**(internal)
```
### ps_trace.tag_v_eq
This function is a part of custom _ps_trace.tag_v type which is a wrapper for
the built-in jsonb. It is the same as its jsonb_ namesake, but has a support function attached.
```
function boolean **ps_trace.tag_v_eq**(_ps_trace.tag_v, _ps_trace.tag_v)
```
### ps_trace.tag_v_eq
This function is a part of custom _ps_trace.tag_v type which is a wrapper for
the built-in jsonb. It is the same as its jsonb_ namesake, but has a support function attached.
```
function boolean **ps_trace.tag_v_eq**(_ps_trace.tag_v, jsonb)
```
### ps_trace.tag_v_ge
This function is a part of custom _ps_trace.tag_v type which is a wrapper for the built-in jsonb. It is the same as its jsonb_ namesake.
```
function boolean **ps_trace.tag_v_ge**(_ps_trace.tag_v, _ps_trace.tag_v)
```
### ps_trace.tag_v_gt
This function is a part of custom _ps_trace.tag_v type which is a wrapper for the built-in jsonb. It is the same as its jsonb_ namesake.
```
function boolean **ps_trace.tag_v_gt**(_ps_trace.tag_v, _ps_trace.tag_v)
```
### ps_trace.tag_v_le
This function is a part of custom _ps_trace.tag_v type which is a wrapper for the built-in jsonb. It is the same as its jsonb_ namesake.
```
function boolean **ps_trace.tag_v_le**(_ps_trace.tag_v, _ps_trace.tag_v)
```
### ps_trace.tag_v_lt
This function is a part of custom _ps_trace.tag_v type which is a wrapper for the built-in jsonb. It is the same as its jsonb_ namesake.
```
function boolean **ps_trace.tag_v_lt**(_ps_trace.tag_v, _ps_trace.tag_v)
```
### ps_trace.tag_v_ne
This function is a part of custom _ps_trace.tag_v type which is a wrapper for
the built-in jsonb. It is the same as its jsonb_ namesake, but has a support function attached.
```
function boolean **ps_trace.tag_v_ne**(_ps_trace.tag_v, _ps_trace.tag_v)
```
### ps_trace.tag_v_ne
This function is a part of custom _ps_trace.tag_v type which is a wrapper for
the built-in jsonb. It is the same as its jsonb_ namesake, but has a support function attached.
```
function boolean **ps_trace.tag_v_ne**(_ps_trace.tag_v, jsonb)
```
### ps_trace.trace_tree
This function returns a set of all spans for a given trace_id. Additionally, parent span,
nesting level and a path (as an array of span_id) are supplied for each span in the set.
```
function TABLE(trace_id trace_id, parent_span_id bigint, span_id bigint, lvl integer, path bigint[]) **ps_trace.trace_tree**(_trace_id trace_id)
```
### ps_trace.upstream_spans
For a given trace_id and span_id this function returns a set that consists of the all spans starting
from the specified span and up to the root of the trace. Each span is annotated with parent_span_id,
a distance from the specified span (the span itself has the distance of 0) and a path from the specified span 
towards the root. Optional third argument allows to limit the span tree traversal to a certain distance from 
the specified span_id.
```
function TABLE(trace_id trace_id, parent_span_id bigint, span_id bigint, dist integer, path bigint[]) **ps_trace.upstream_spans**(_trace_id trace_id, _span_id bigint, _max_dist integer DEFAULT NULL::integer)
```
### _prom_catalog.add_compression_clause_to_downsample_view

```
procedure void **_prom_catalog.add_compression_clause_to_downsample_view**(IN _schema text, IN _table_name text)
```
### _prom_catalog.attach_series_partition

```
function void **_prom_catalog.attach_series_partition**(metric_record _prom_catalog.metric)
```
### _prom_catalog.compress_chunk_for_hypertable

```
function void **_prom_catalog.compress_chunk_for_hypertable**(_hypertable_schema_name text, _hypertable_table_name text, _chunk_schema_name text, _chunk_table_name text)
```
### _prom_catalog.compress_metric_chunks

```
procedure void **_prom_catalog.compress_metric_chunks**(IN metric_name text)
```
### _prom_catalog.compress_old_chunks

```
procedure void **_prom_catalog.compress_old_chunks**(IN _hypertable_schema_name text, IN _hypertable_table_name text, IN _compress_before timestamp with time zone)
```
### _prom_catalog.count_jsonb_keys

```
function integer **_prom_catalog.count_jsonb_keys**(j jsonb)
```
### _prom_catalog.counter_reset_sum

```
function double precision **_prom_catalog.counter_reset_sum**(v double precision[])
```
### _prom_catalog.create_cagg_refresh_job_if_not_exists
Creates a Cagg refresh job that refreshes all Caggs registered by register_metric_view().
This function creates a refresh job only if no execute_caggs_refresh_policy() exists currently with the given refresh_interval.
```
function void **_prom_catalog.create_cagg_refresh_job_if_not_exists**(_refresh_interval interval)
```
### _prom_catalog.create_default_downsampling_query_view

```
function void **_prom_catalog.create_default_downsampling_query_view**(_schema text, _table_name text, _default_column text)
```
### _prom_catalog.create_exemplar_table_if_not_exists

```
function boolean **_prom_catalog.create_exemplar_table_if_not_exists**(metric_name text)
```
### _prom_catalog.create_ingest_temp_table
Creates a temporary table (if it doesn't exist) used for ingestion of metrics or traces.
Temporary table is created using supplied table and schema as prototype.
Suppresses corresponding DDL logging, otherwise PG log may get unnecessarily verbose.
Api user has to make sure that table_prefix is unique per session/connection.
This is to prevent different truncated table names having same temp table.
Returns temporary table name
```
function text **_prom_catalog.create_ingest_temp_table**(table_name text, schema_name text, table_prefix text)
```
### _prom_catalog.create_label_key

```
function record **_prom_catalog.create_label_key**(new_key text, OUT id integer, OUT value_column_name name, OUT id_column_name name)
```
### _prom_catalog.create_metric_downsampling_view

```
function boolean **_prom_catalog.create_metric_downsampling_view**(_schema text, _metric_name text, _table_name text, _resolution interval)
```
### _prom_catalog.create_metric_table

```
function record **_prom_catalog.create_metric_table**(metric_name_arg text, OUT id integer, OUT table_name name)
```
### _prom_catalog.create_metric_view

```
function boolean **_prom_catalog.create_metric_view**(metric_name text)
```
### _prom_catalog.create_or_update_downsampling

```
procedure void **_prom_catalog.create_or_update_downsampling**(IN _schema_name text, IN _resolution interval, IN _retention interval)
```
### _prom_catalog.create_series

```
function bigint **_prom_catalog.create_series**(metric_id integer, metric_table_name text, label_array label_array, OUT series_id bigint)
```
### _prom_catalog.create_series_view

```
function boolean **_prom_catalog.create_series_view**(metric_name text)
```
### _prom_catalog.decompress_chunk_for_metric

```
function void **_prom_catalog.decompress_chunk_for_metric**(metric_table text, chunk_schema_name text, chunk_table_name text)
```
### _prom_catalog.decompress_chunks_after

```
procedure void **_prom_catalog.decompress_chunks_after**(IN metric_table text, IN min_time timestamp with time zone, IN transactional boolean DEFAULT false)
```
### _prom_catalog.delay_compression_job

```
function void **_prom_catalog.delay_compression_job**(ht_table text, new_start timestamp with time zone)
```
### _prom_catalog.delete_downsampling

```
procedure void **_prom_catalog.delete_downsampling**(IN _schema_name text)
```
### _prom_catalog.delete_expired_series

```
function void **_prom_catalog.delete_expired_series**(metric_schema text, metric_table text, metric_series_table text, ran_at timestamp with time zone, present_epoch bigint, last_updated_epoch timestamp with time zone)
```
### _prom_catalog.delete_series_catalog_row

```
function void **_prom_catalog.delete_series_catalog_row**(metric_table text, series_ids bigint[])
```
### _prom_catalog.delete_series_from_metric

```
function bigint **_prom_catalog.delete_series_from_metric**(name text, series_ids bigint[])
```
### _prom_catalog.do_decompress_chunks_after

```
procedure void **_prom_catalog.do_decompress_chunks_after**(IN metric_table text, IN min_time timestamp with time zone, IN transactional boolean DEFAULT false)
```
### _prom_catalog.downsample_counter

```
procedure void **_prom_catalog.downsample_counter**(IN _schema text, IN _table_name text, IN _resolution interval)
```
### _prom_catalog.downsample_gauge

```
procedure void **_prom_catalog.downsample_gauge**(IN _schema text, IN _table_name text, IN _resolution interval)
```
### _prom_catalog.downsample_summary

```
procedure void **_prom_catalog.downsample_summary**(IN _schema text, IN _table_name text, IN _resolution interval)
```
### _prom_catalog.drop_metric_chunk_data
drop chunks from schema_name.metric_name containing data older than older_than.
```
function void **_prom_catalog.drop_metric_chunk_data**(schema_name text, metric_name text, older_than timestamp with time zone)
```
### _prom_catalog.drop_metric_chunks

```
procedure void **_prom_catalog.drop_metric_chunks**(IN schema_name text, IN metric_name text, IN older_than timestamp with time zone, IN ran_at timestamp with time zone DEFAULT now(), IN log_verbose boolean DEFAULT false)
```
### _prom_catalog.epoch_abort
ABORT an INSERT transaction due to the ID epoch being out of date
```
function void **_prom_catalog.epoch_abort**(user_epoch bigint)
```
### _prom_catalog.execute_caggs_compression_policy
execute_caggs_compression_policy is responsible to compress Caggs registered via
register_metric_view() in _prom_catalog.metric. It goes through all the entries in the _prom_catalog.metric and tries to compress any Cagg that supports compression.
These include automatic-downsampling of metrics and custom Caggs based downsampling.
Note: execute_caggs_compression_policy runs every X interval and compresses only the inactive chunks of those Caggs which have timescaledb.compress = true.
```
procedure void **_prom_catalog.execute_caggs_compression_policy**(IN job_id integer, IN config jsonb)
```
### _prom_catalog.execute_caggs_refresh_policy
execute_caggs_refresh_policy runs every refresh_interval passed in config. Its
main aim is to refresh those Caggs that have been registered under _prom_catalog.metric and whose view_refresh_interval
matches the given refresh_interval. It refreshes 2 kinds of Caggs:
1. Caggs created by metric downsampling
2. Custom Caggs created by the user
```
procedure void **_prom_catalog.execute_caggs_refresh_policy**(IN job_id integer, IN config jsonb)
```
### _prom_catalog.execute_caggs_retention_policy
execute_caggs_retention_policy is responsible to perform retention behaviour on continuous aggregates registered via
register_metric_view(). It loops through all entries in the _prom_catalog.metric that are Caggs and tries to delete the stale chunks of those Caggs.
The staleness is determined by _prom_catalog.downsample.retention (for metric downsampling) and default_retention_period of parent hypertable (for custom Caggs).
These include automatic-downsampling for metrics and custom Caggs based downsampling.
```
procedure void **_prom_catalog.execute_caggs_retention_policy**(IN job_id integer, IN config jsonb)
```
### _prom_catalog.execute_compression_policy
compress data according to the policy. This procedure should be run regularly in a cron job
```
procedure void **_prom_catalog.execute_compression_policy**(IN log_verbose boolean DEFAULT false)
```
### _prom_catalog.execute_data_retention_policy
drops old data according to the data retention policy. This procedure should be run regularly in a cron job
```
procedure void **_prom_catalog.execute_data_retention_policy**(IN log_verbose boolean)
```
### _prom_catalog.execute_everywhere

```
procedure void **_prom_catalog.execute_everywhere**(IN command_key text, IN command text, IN transactional boolean DEFAULT true)
```
### _prom_catalog.execute_maintenance_job

```
procedure void **_prom_catalog.execute_maintenance_job**(IN job_id integer, IN config jsonb)
```
### _prom_catalog.finalize_metric_creation
Finalizes metric creation. This procedure should be run by the connector automatically
```
procedure void **_prom_catalog.finalize_metric_creation**()
```
### _prom_catalog.get_advisory_lock_id_vacuum_engine
Returns the lock id used to coordinate runs of the vacuum engine
```
function bigint **_prom_catalog.get_advisory_lock_id_vacuum_engine**()
```
### _prom_catalog.get_advisory_lock_prefix_job

```
function integer **_prom_catalog.get_advisory_lock_prefix_job**()
```
### _prom_catalog.get_advisory_lock_prefix_maintenance

```
function integer **_prom_catalog.get_advisory_lock_prefix_maintenance**()
```
### _prom_catalog.get_cagg_info

```
function record **_prom_catalog.get_cagg_info**(metric_schema text, metric_table text, OUT is_cagg boolean, OUT cagg_schema name, OUT cagg_name name, OUT metric_table_name name, OUT materialized_hypertable_id integer, OUT storage_hypertable_relation text)
```
### _prom_catalog.get_confirmed_unused_series

Given a `metric_schema`, `metric_table`, and `series_table`, this function
returns all series ids in `potential_series_ids` which are not referenced by
data newer than `newer_than` in any metric table.
Note: See _prom_catalog.mark_series_to_be_dropped_as_unused for context.

```
function bigint[] **_prom_catalog.get_confirmed_unused_series**(metric_schema text, metric_table text, series_table text, potential_series_ids bigint[], newer_than timestamp with time zone)
```
### _prom_catalog.get_default_chunk_interval

```
function interval **_prom_catalog.get_default_chunk_interval**()
```
### _prom_catalog.get_default_compression_setting

```
function boolean **_prom_catalog.get_default_compression_setting**()
```
### _prom_catalog.get_default_retention_period

```
function interval **_prom_catalog.get_default_retention_period**()
```
### _prom_catalog.get_default_value

```
function text **_prom_catalog.get_default_value**(_key text)
```
### _prom_catalog.get_exemplar_label_key_positions

```
function json **_prom_catalog.get_exemplar_label_key_positions**(metric_name text)
```
### _prom_catalog.get_first_level_view_on_metric

```
function TABLE(view_schema name, view_name name, metric_table_name name) **_prom_catalog.get_first_level_view_on_metric**(metric_schema text, metric_table text)
```
### _prom_catalog.get_label_key_column_name_for_view

```
function name **_prom_catalog.get_label_key_column_name_for_view**(label_key text, id boolean)
```
### _prom_catalog.get_metric_compression_setting

```
function boolean **_prom_catalog.get_metric_compression_setting**(metric_name text)
```
### _prom_catalog.get_metric_retention_period

```
function interval **_prom_catalog.get_metric_retention_period**(metric_name text)
```
### _prom_catalog.get_metric_retention_period

```
function interval **_prom_catalog.get_metric_retention_period**(schema_name text, metric_name text)
```
### _prom_catalog.get_metric_table_name_if_exists

```
function TABLE(id integer, table_name name, table_schema name, series_table name, is_view boolean) **_prom_catalog.get_metric_table_name_if_exists**(schema text, metric_name text)
```
### _prom_catalog.get_metrics_that_need_drop_chunk

```
function SETOF _prom_catalog.metric **_prom_catalog.get_metrics_that_need_drop_chunk**()
```
### _prom_catalog.get_new_label_id

```
function integer **_prom_catalog.get_new_label_id**(key_name text, value_name text, OUT id integer)
```
### _prom_catalog.get_new_pos_for_key

```
function integer[] **_prom_catalog.get_new_pos_for_key**(metric_name text, metric_table text, key_name_array text[], is_for_exemplar boolean)
```
### _prom_catalog.get_or_create_label_array
converts a jsonb to a label array
```
function label_array **_prom_catalog.get_or_create_label_array**(js jsonb)
```
### _prom_catalog.get_or_create_label_array
converts a metric name, array of keys, and array of values to a label array
```
function label_array **_prom_catalog.get_or_create_label_array**(metric_name text, label_keys text[], label_values text[])
```
### _prom_catalog.get_or_create_label_id

```
function integer **_prom_catalog.get_or_create_label_id**(key_name text, value_name text)
```
### _prom_catalog.get_or_create_label_ids
converts a metric name, array of keys, and array of values to a list of label ids
```
function TABLE(pos integer[], id integer[], label_key text[], label_value text[]) **_prom_catalog.get_or_create_label_ids**(metric_name text, metric_table text, label_keys text[], label_values text[])
```
### _prom_catalog.get_or_create_label_key

```
function record **_prom_catalog.get_or_create_label_key**(key text, OUT id integer, OUT value_column_name name, OUT id_column_name name)
```
### _prom_catalog.get_or_create_label_key_pos

```
function integer **_prom_catalog.get_or_create_label_key_pos**(metric_name text, key text)
```
### _prom_catalog.get_or_create_metric_table_name

```
function record **_prom_catalog.get_or_create_metric_table_name**(metric_name text, OUT id integer, OUT table_name name, OUT possibly_new boolean)
```
### _prom_catalog.get_or_create_series_id
returns the series id that exactly matches a JSONB of labels
```
function bigint **_prom_catalog.get_or_create_series_id**(label jsonb)
```
### _prom_catalog.get_or_create_series_id_for_kv_array

```
function record **_prom_catalog.get_or_create_series_id_for_kv_array**(metric_name text, label_keys text[], label_values text[], OUT table_name name, OUT series_id bigint)
```
### _prom_catalog.get_or_create_series_id_for_label_array

```
function bigint **_prom_catalog.get_or_create_series_id_for_label_array**(metric_id integer, table_name text, larray label_array, OUT series_id bigint)
```
### _prom_catalog.get_staggered_chunk_interval

```
function interval **_prom_catalog.get_staggered_chunk_interval**(chunk_interval interval)
```
### _prom_catalog.get_storage_hypertable_info

```
function TABLE(id integer, hypertable_relation text) **_prom_catalog.get_storage_hypertable_info**(metric_schema_name text, metric_table_name text, is_view boolean)
```
### _prom_catalog.get_timescale_major_version

```
function integer **_prom_catalog.get_timescale_major_version**()
```
### _prom_catalog.get_timescale_minor_version

```
function integer **_prom_catalog.get_timescale_minor_version**()
```
### _prom_catalog.ha_leases_audit_fn

```
function trigger **_prom_catalog.ha_leases_audit_fn**()
```
### _prom_catalog.hypertable_compression_stats_for_schema

```
function TABLE(hypertable_name text, total_chunks bigint, number_compressed_chunks bigint, before_compression_total_bytes bigint, after_compression_total_bytes bigint) **_prom_catalog.hypertable_compression_stats_for_schema**(schema_name_in text)
```
### _prom_catalog.hypertable_local_size

```
function TABLE(hypertable_name text, table_bytes bigint, index_bytes bigint, toast_bytes bigint, total_bytes bigint) **_prom_catalog.hypertable_local_size**(schema_name_in text)
```
### _prom_catalog.hypertable_node_up

```
function TABLE(hypertable_name text, node_name text, node_up boolean) **_prom_catalog.hypertable_node_up**(schema_name_in text)
```
### _prom_catalog.hypertable_remote_size

```
function TABLE(hypertable_name text, table_bytes bigint, index_bytes bigint, toast_bytes bigint, total_bytes bigint) **_prom_catalog.hypertable_remote_size**(schema_name_in text)
```
### _prom_catalog.insert_exemplar_row

```
function bigint **_prom_catalog.insert_exemplar_row**(metric_table text, time_array timestamp with time zone[], series_id_array bigint[], exemplar_label_values_array label_value_array[], value_array double precision[])
```
### _prom_catalog.insert_metric_metadatas

```
function bigint **_prom_catalog.insert_metric_metadatas**(t timestamp with time zone[], metric_family_name text[], metric_type text[], metric_unit text[], metric_help text[])
```
### _prom_catalog.insert_metric_row

```
function bigint **_prom_catalog.insert_metric_row**(metric_table text, time_array timestamp with time zone[], value_array double precision[], series_id_array bigint[])
```
### _prom_catalog.irate

```
function double precision **_prom_catalog.irate**(v double precision[])
```
### _prom_catalog.is_multinode

```
function boolean **_prom_catalog.is_multinode**()
```
### _prom_catalog.is_restore_in_progress

```
function boolean **_prom_catalog.is_restore_in_progress**()
```
### _prom_catalog.is_timescaledb_installed

```
function boolean **_prom_catalog.is_timescaledb_installed**()
```
### _prom_catalog.is_timescaledb_oss

```
function boolean **_prom_catalog.is_timescaledb_oss**()
```
### _prom_catalog.label_contains

```
function boolean **_prom_catalog.label_contains**(labels label_array, json_labels jsonb)
```
### _prom_catalog.label_find_key_equal

```
function matcher_positive **_prom_catalog.label_find_key_equal**(key_to_match label_key, pat pattern)
```
### _prom_catalog.label_find_key_not_equal

```
function matcher_negative **_prom_catalog.label_find_key_not_equal**(key_to_match label_key, pat pattern)
```
### _prom_catalog.label_find_key_not_regex

```
function matcher_negative **_prom_catalog.label_find_key_not_regex**(key_to_match label_key, pat pattern)
```
### _prom_catalog.label_find_key_regex

```
function matcher_positive **_prom_catalog.label_find_key_regex**(key_to_match label_key, pat pattern)
```
### _prom_catalog.label_jsonb_each_text

```
function SETOF record **_prom_catalog.label_jsonb_each_text**(js jsonb, OUT key text, OUT value text)
```
### _prom_catalog.label_match

```
function boolean **_prom_catalog.label_match**(labels label_array, matchers matcher_negative)
```
### _prom_catalog.label_match

```
function boolean **_prom_catalog.label_match**(labels label_array, matchers matcher_positive)
```
### _prom_catalog.label_unnest

```
function SETOF anyelement **_prom_catalog.label_unnest**(label_array anyarray)
```
### _prom_catalog.label_value_contains

```
function boolean **_prom_catalog.label_value_contains**(labels label_value_array, label_value text)
```
### _prom_catalog.lock_for_vacuum_engine
Attempts to acquire an advisory lock for the vacuum engine
```
function boolean **_prom_catalog.lock_for_vacuum_engine**()
```
### _prom_catalog.lock_metric_for_maintenance

```
function boolean **_prom_catalog.lock_metric_for_maintenance**(metric_id integer, wait boolean DEFAULT true)
```
### _prom_catalog.make_metric_table

```
function trigger **_prom_catalog.make_metric_table**()
```
### _prom_catalog.mark_series_to_be_dropped_as_unused

Marks series which we will drop soon as unused.
A series is unused if there is no data newer than `drop_point` which
references that series.
Note: This function can only mark a series as unused if there is still
data which references that series.
This function is designed to be used in the context of dropping metric
chunks, see `_prom_catalog.drop_metric_chunks`.

```
function void **_prom_catalog.mark_series_to_be_dropped_as_unused**(metric_schema text, metric_table text, metric_series_table text, drop_point timestamp with time zone)
```
### _prom_catalog.match_equals

```
function boolean **_prom_catalog.match_equals**(labels label_array, _op tag_op_equals)
```
### _prom_catalog.match_not_equals

```
function boolean **_prom_catalog.match_not_equals**(labels label_array, _op tag_op_not_equals)
```
### _prom_catalog.match_regexp_matches

```
function boolean **_prom_catalog.match_regexp_matches**(labels label_array, _op tag_op_regexp_matches)
```
### _prom_catalog.match_regexp_not_matches

```
function boolean **_prom_catalog.match_regexp_not_matches**(labels label_array, _op tag_op_regexp_not_matches)
```
### _prom_catalog.metric_chunks_that_need_to_be_compressed

```
function TABLE(metric_id integer, metric_name text, hypertable_id integer, table_name text, chunks_to_compress jsonb) **_prom_catalog.metric_chunks_that_need_to_be_compressed**(_older_than interval)
```
### _prom_catalog.metric_detail
Returns details describing each metric table including disk sizes
```
function TABLE(id integer, metric_name text, table_name text, label_keys text[], retention_period interval, chunk_interval interval, compressed_interval interval, total_interval interval, before_compression_bytes bigint, after_compression_bytes bigint, total_size_bytes bigint, total_size text, compression_ratio numeric, total_chunks bigint, compressed_chunks bigint) **_prom_catalog.metric_detail**()
```
### _prom_catalog.pg_name_unique

```
function name **_prom_catalog.pg_name_unique**(full_name_arg text, suffix text)
```
### _prom_catalog.pg_name_with_suffix

```
function name **_prom_catalog.pg_name_with_suffix**(full_name text, suffix text)
```
### _prom_catalog.resurrect_series_ids

```
function void **_prom_catalog.resurrect_series_ids**(metric_table text, series_id bigint)
```
### _prom_catalog.safe_approximate_row_count

```
function bigint **_prom_catalog.safe_approximate_row_count**(table_name_input regclass)
```
### _prom_catalog.scan_for_new_downsampling_views

```
procedure void **_prom_catalog.scan_for_new_downsampling_views**(IN job_id integer, IN config jsonb)
```
### _prom_catalog.set_app_name

```
function void **_prom_catalog.set_app_name**(full_name text)
```
### _prom_catalog.set_chunk_interval_on_metric_table

```
function void **_prom_catalog.set_chunk_interval_on_metric_table**(metric_name text, new_interval interval)
```
### _prom_catalog.set_default_value

```
function void **_prom_catalog.set_default_value**(_key text, _value text)
```
### _prom_catalog.try_change_leader

```
function _prom_catalog.ha_leases **_prom_catalog.try_change_leader**(cluster text, new_leader text, max_time timestamp with time zone)
```
### _prom_catalog.unlock_for_vacuum_engine
Releases the advisory lock used by the vacuum engine
```
function void **_prom_catalog.unlock_for_vacuum_engine**()
```
### _prom_catalog.unlock_metric_for_maintenance

```
function void **_prom_catalog.unlock_metric_for_maintenance**(metric_id integer)
```
### _prom_catalog.update_downsampling_state

```
function void **_prom_catalog.update_downsampling_state**(_schema_name text, _should_refresh boolean)
```
### _prom_catalog.update_execute_everywhere_entry

```
procedure void **_prom_catalog.update_execute_everywhere_entry**(IN command_key text, IN command text, IN transactional boolean DEFAULT true)
```
### _prom_catalog.update_lease

```
function _prom_catalog.ha_leases **_prom_catalog.update_lease**(cluster text, writer text, min_time timestamp with time zone, max_time timestamp with time zone)
```
### _prom_ext.gapfilldeltatransition_in

```
function _prom_ext.gapfilldeltatransition **_prom_ext.gapfilldeltatransition_in**(input cstring)
```
### _prom_ext.gapfilldeltatransition_out

```
function cstring **_prom_ext.gapfilldeltatransition_out**(input _prom_ext.gapfilldeltatransition)
```
### _prom_ext.jsonb_digest

```
function bytea **_prom_ext.jsonb_digest**(jsonb jsonb)
```
### _prom_ext.num_cpus

```
function integer **_prom_ext.num_cpus**()
```
### _prom_ext.prom_delta

```
aggregate double precision[] **_prom_ext.prom_delta**(lowest_time timestamp with time zone, greatest_time timestamp with time zone, step_size bigint, range bigint, sample_time timestamp with time zone, sample_value double precision)
```
### _prom_ext.prom_delta_transition

```
function internal **_prom_ext.prom_delta_transition**(state internal, lowest_time timestamp with time zone, greatest_time timestamp with time zone, step_size bigint, range bigint, sample_time timestamp with time zone, sample_value double precision)
```
### _prom_ext.prom_extrapolate_final

```
function double precision[] **_prom_ext.prom_extrapolate_final**(state internal)
```
### _prom_ext.prom_increase

```
aggregate double precision[] **_prom_ext.prom_increase**(lowest_time timestamp with time zone, greatest_time timestamp with time zone, step_size bigint, range bigint, sample_time timestamp with time zone, sample_value double precision)
```
### _prom_ext.prom_increase_transition

```
function internal **_prom_ext.prom_increase_transition**(state internal, lowest_time timestamp with time zone, greatest_time timestamp with time zone, step_size bigint, range bigint, sample_time timestamp with time zone, sample_value double precision)
```
### _prom_ext.prom_rate

```
aggregate double precision[] **_prom_ext.prom_rate**(lowest_time timestamp with time zone, greatest_time timestamp with time zone, step_size bigint, range bigint, sample_time timestamp with time zone, sample_value double precision)
```
### _prom_ext.prom_rate_transition

```
function internal **_prom_ext.prom_rate_transition**(state internal, lowest_time timestamp with time zone, greatest_time timestamp with time zone, step_size bigint, range bigint, sample_time timestamp with time zone, sample_value double precision)
```
### _prom_ext.re2_match

```
function boolean **_prom_ext.re2_match**(string text, pattern text)
```
### _prom_ext.rewrite_fn_call_to_subquery

```
function internal **_prom_ext.rewrite_fn_call_to_subquery**(input internal)
```
### _prom_ext.tag_map_rewrite

```
function internal **_prom_ext.tag_map_rewrite**(input internal)
```
### _prom_ext.update_tsprom_metadata

```
function void **_prom_ext.update_tsprom_metadata**(meta_key text, meta_value text, send_telemetry boolean)
```
### _prom_ext.vector_selector

```
aggregate double precision[] **_prom_ext.vector_selector**(start_time timestamp with time zone, end_time timestamp with time zone, bucket_width bigint, lookback bigint, sample_time timestamp with time zone, sample_value double precision)
```
### _prom_ext.vector_selector_combine

```
function internal **_prom_ext.vector_selector_combine**(state1 internal, state2 internal)
```
### _prom_ext.vector_selector_deserialize

```
function internal **_prom_ext.vector_selector_deserialize**(bytes bytea, _internal internal)
```
### _prom_ext.vector_selector_final

```
function double precision[] **_prom_ext.vector_selector_final**(state internal)
```
### _prom_ext.vector_selector_serialize

```
function bytea **_prom_ext.vector_selector_serialize**(state internal)
```
### _prom_ext.vector_selector_transition

```
function internal **_prom_ext.vector_selector_transition**(state internal, start_time timestamp with time zone, end_time timestamp with time zone, bucket_width bigint, lookback bigint, "time" timestamp with time zone, value double precision)
```
### _ps_catalog.apply_telemetry

```
function void **_ps_catalog.apply_telemetry**(telemetry_name text, telemetry_value text)
```
### _ps_catalog.promscale_sql_telemetry

```
function void **_ps_catalog.promscale_sql_telemetry**()
```
### _ps_catalog.promscale_telemetry_housekeeping

```
function boolean **_ps_catalog.promscale_telemetry_housekeeping**(telemetry_sync_duration interval DEFAULT '01:00:00'::interval)
```
### _ps_trace.drop_event_chunks
This procedure drops chunks of _ps_trace.event hypertable that are older than a specified timestamp.
```
procedure void **_ps_trace.drop_event_chunks**(IN _older_than timestamp with time zone)
```
### _ps_trace.drop_link_chunks
This procedure drops chunks of _ps_trace.link hypertable that are older than a specified timestamp.
```
procedure void **_ps_trace.drop_link_chunks**(IN _older_than timestamp with time zone)
```
### _ps_trace.drop_span_chunks
This procedure drops chunks of _ps_trace.span hypertable that are older than a specified timestamp.
```
procedure void **_ps_trace.drop_span_chunks**(IN _older_than timestamp with time zone)
```
### _ps_trace.ensure_trace_ingest_temp_table
Note: This function is getting deprecated. New versions of connector will use _prom_catalog.create_ingest_temp_table.
Creates a temporary table (if it doesn't exist), suitable for tracing data ingestion. 
Supresses corresponding DDL logging, otherwise PG log may get unnecessarily verbose.
```
function void **_ps_trace.ensure_trace_ingest_temp_table**(_temp_table_name text, _proto_table_name text)
```
### _ps_trace.execute_data_retention_policy
drops old data according to the data retention policy. This procedure should be run regularly in a cron job
```
procedure void **_ps_trace.execute_data_retention_policy**(IN log_verbose boolean)
```
### _ps_trace.execute_tracing_compression
Execute tracing compression compresses tracing tables
```
procedure void **_ps_trace.execute_tracing_compression**(IN hypertable_name text, IN log_verbose boolean DEFAULT false)
```
### _ps_trace.execute_tracing_compression_job

```
procedure void **_ps_trace.execute_tracing_compression_job**(IN job_id integer, IN config jsonb)
```
### _ps_trace.tag_map_denormalize
Given a json object of (ps_trace.tag_key.id, ps_trace.tag.id) this function
performs necessary lookups and returns a reconstructed set of open telemetry tags
as a tag_map.
```
function tag_map **_ps_trace.tag_map_denormalize**(_map tag_map)
```
### _ps_trace.tag_v_cmp
This function is a part of custom _ps_trace.tag_v type which is a wrapper for the built-in jsonb. It is the same as its jsonb_ namesake.
```
function integer **_ps_trace.tag_v_cmp**(_ps_trace.tag_v, _ps_trace.tag_v)
```
### _ps_trace.tag_v_eq_matching_tags
This function is a part of custom _ps_trace.tag_v type which is a wrapper for
the built-in jsonb. The tag_map_rewrite support function, attached to tag_v_eq,
will use this function instead, if it can.
```
function jsonb **_ps_trace.tag_v_eq_matching_tags**(_tag_key text, _value jsonb)
```
### _ps_trace.tag_v_in
This function is a part of custom _ps_trace.tag_v type which is a wrapper for the built-in jsonb. It is the same as its jsonb_ namesake.
```
function _ps_trace.tag_v **_ps_trace.tag_v_in**(cstring)
```
### _ps_trace.tag_v_ne_matching_tags
This function is a part of custom _ps_trace.tag_v type which is a wrapper for
the built-in jsonb. The tag_map_rewrite support function, attached to tag_v_ne,
will use this function instead, if it can.
```
function jsonb[] **_ps_trace.tag_v_ne_matching_tags**(_tag_key text, _value jsonb)
```
### _ps_trace.tag_v_out
This function is a part of custom _ps_trace.tag_v type which is a wrapper for the built-in jsonb. It is the same as its jsonb_ namesake.
```
function cstring **_ps_trace.tag_v_out**(_ps_trace.tag_v)
```
### _ps_trace.tag_v_recv
This function is a part of custom _ps_trace.tag_v type which is a wrapper for the built-in jsonb. It is the same as its jsonb_ namesake.
```
function _ps_trace.tag_v **_ps_trace.tag_v_recv**(internal)
```
### _ps_trace.tag_v_send
This function is a part of custom _ps_trace.tag_v type which is a wrapper for the built-in jsonb. It is the same as its jsonb_ namesake.
```
function bytea **_ps_trace.tag_v_send**(_ps_trace.tag_v)
```
### _ps_trace.tag_v_subscript_handler
This function is a part of custom _ps_trace.tag_v type which is a wrapper for the built-in jsonb. It is the same as its jsonb_ namesake.
```
function internal **_ps_trace.tag_v_subscript_handler**(internal)
```
### _ps_trace.tag_v_text_eq_matching_tags
This function is a part of custom _ps_trace.tag_v type which is a wrapper for
the built-in jsonb. This function returns all the jsonb { tag_key_id, tag_value_id } pairs where
the tag key matches _tag_key and the textual output of tag value matches _tag_value_text
```
function jsonb[] **_ps_trace.tag_v_text_eq_matching_tags**(_tag_key text, _tag_value_text text)
```
### _ps_trace.text_matches
This function is an internal function that given a peice of text, returns all the possible
jsonb representations of that text. I.e. it is the inverse of the jsonb ->> operator.
```
function jsonb[] **_ps_trace.text_matches**(_value text)
```
### _ps_trace.trace_id_cmp
This function is a part of custom ps_trace.tag_traceid type which is a wrapper for the built-in uuid. It is the same as its uuid_ namesake.
```
function integer **_ps_trace.trace_id_cmp**(trace_id, trace_id)
```
### _ps_trace.trace_id_eq
This function is a part of custom ps_trace.tag_traceid type which is a wrapper for the built-in uuid. It is the same as its uuid_ namesake.
```
function boolean **_ps_trace.trace_id_eq**(trace_id, trace_id)
```
### _ps_trace.trace_id_ge
This function is a part of custom ps_trace.tag_traceid type which is a wrapper for the built-in uuid. It is the same as its uuid_ namesake.
```
function boolean **_ps_trace.trace_id_ge**(trace_id, trace_id)
```
### _ps_trace.trace_id_gt
This function is a part of custom ps_trace.tag_traceid type which is a wrapper for the built-in uuid. It is the same as its uuid_ namesake.
```
function boolean **_ps_trace.trace_id_gt**(trace_id, trace_id)
```
### _ps_trace.trace_id_hash
This function is a part of custom ps_trace.tag_traceid type which is a wrapper for the built-in uuid. It is the same as its uuid_ namesake.
```
function integer **_ps_trace.trace_id_hash**(trace_id)
```
### _ps_trace.trace_id_in
This function is a part of custom ps_trace.tag_traceid type which is a wrapper for the built-in uuid. It is the same as its uuid_ namesake.
```
function trace_id **_ps_trace.trace_id_in**(cstring)
```
### _ps_trace.trace_id_le
This function is a part of custom ps_trace.tag_traceid type which is a wrapper for the built-in uuid. It is the same as its uuid_ namesake.
```
function boolean **_ps_trace.trace_id_le**(trace_id, trace_id)
```
### _ps_trace.trace_id_lt
This function is a part of custom ps_trace.tag_traceid type which is a wrapper for the built-in uuid. It is the same as its uuid_ namesake.
```
function boolean **_ps_trace.trace_id_lt**(trace_id, trace_id)
```
### _ps_trace.trace_id_ne
This function is a part of custom ps_trace.tag_traceid type which is a wrapper for the built-in uuid. It is the same as its uuid_ namesake.
```
function boolean **_ps_trace.trace_id_ne**(trace_id, trace_id)
```
### _ps_trace.trace_id_out
This function is a part of custom ps_trace.tag_traceid type which is a wrapper for the built-in uuid. It is the same as its uuid_ namesake.
```
function cstring **_ps_trace.trace_id_out**(trace_id)
```
### _ps_trace.trace_id_recv
This function is a part of custom ps_trace.tag_traceid type which is a wrapper for the built-in uuid. It is the same as its uuid_ namesake.
```
function trace_id **_ps_trace.trace_id_recv**(internal)
```
### _ps_trace.trace_id_send
This function is a part of custom ps_trace.tag_traceid type which is a wrapper for the built-in uuid. It is the same as its uuid_ namesake.
```
function bytea **_ps_trace.trace_id_send**(trace_id)
```
## Operators
### label_array ? matcher_negative → boolean


__Function:__ _prom_catalog.label_match

__Schema:__ prom_api
### label_array ? matcher_positive → boolean


__Function:__ _prom_catalog.label_match

__Schema:__ prom_api
### label_array ? tag_op_equals → boolean


__Function:__ _prom_catalog.match_equals

__Schema:__ prom_api
### label_array ? tag_op_not_equals → boolean


__Function:__ _prom_catalog.match_not_equals

__Schema:__ prom_api
### label_array ? tag_op_regexp_matches → boolean


__Function:__ _prom_catalog.match_regexp_matches

__Schema:__ prom_api
### label_array ? tag_op_regexp_not_matches → boolean


__Function:__ _prom_catalog.match_regexp_not_matches

__Schema:__ prom_api
### label_array @> jsonb → boolean


__Function:__ _prom_catalog.label_contains

__Schema:__ prom_api
### label_value_array @> text → boolean


__Function:__ _prom_catalog.label_value_contains

__Schema:__ prom_api
### text !== anyelement → tag_op_not_equals
This function supports the !== operator.

__Function:__ tag_op_not_equals

__Schema:__ ps_tag
### text !== text → tag_op_not_equals
This function supports the !== operator.

__Function:__ tag_op_not_equals_text

__Schema:__ ps_tag
### text !=~ text → tag_op_regexp_not_matches
This function supports the !=~ operator.

__Function:__ tag_op_regexp_not_matches

__Schema:__ ps_tag
### text #< anyelement → tag_op_less_than
This function supports the #< operator.

__Function:__ tag_op_less_than

__Schema:__ ps_tag
### text #< text → tag_op_less_than
This function supports the #< operator.

__Function:__ tag_op_less_than_text

__Schema:__ ps_tag
### text #<= anyelement → tag_op_less_than_or_equal
This function supports the #<= operator.

__Function:__ tag_op_less_than_or_equal

__Schema:__ ps_tag
### text #<= text → tag_op_less_than_or_equal
This function supports the #<= operator.

__Function:__ tag_op_less_than_or_equal_text

__Schema:__ ps_tag
### text #> anyelement → tag_op_greater_than
This function supports the #> operator.

__Function:__ tag_op_greater_than

__Schema:__ ps_tag
### text #> text → tag_op_greater_than
This function supports the #> operator.

__Function:__ tag_op_greater_than_text

__Schema:__ ps_tag
### text #>= anyelement → tag_op_greater_than_or_equal
This function supports the #>= operator.

__Function:__ tag_op_greater_than_or_equal

__Schema:__ ps_tag
### text #>= text → tag_op_greater_than_or_equal
This function supports the #>= operator.

__Function:__ tag_op_greater_than_or_equal_text

__Schema:__ ps_tag
### text == anyelement → tag_op_equals
This function supports the == operator.

__Function:__ tag_op_equals

__Schema:__ ps_tag
### text == text → tag_op_equals
This function supports the == operator.

__Function:__ tag_op_equals_text

__Schema:__ ps_tag
### text ==~ text → tag_op_regexp_matches
This function supports the ==~ operator.

__Function:__ tag_op_regexp_matches

__Schema:__ ps_tag
### text @? jsonpath → tag_op_jsonb_path_exists
This function supports the @? operator.

__Function:__ tag_op_jsonb_path_exists

__Schema:__ ps_tag
### _ps_trace.tag_v %< _ps_trace.tag_v → boolean
This operator is a part of custom ps_trace.tag_map type which is a wrapper for
the built-in jsonb. It is the same as its jsonb_ namesake, but relies on tag_map_* functions.

__Function:__ tag_v_lt

__Schema:__ ps_trace
### _ps_trace.tag_v %<= _ps_trace.tag_v → boolean
This operator is a part of custom ps_trace.tag_map type which is a wrapper for
the built-in jsonb. It is the same as its jsonb_ namesake, but relies on tag_map_* functions.

__Function:__ tag_v_le

__Schema:__ ps_trace
### _ps_trace.tag_v %<> _ps_trace.tag_v → boolean
This operator is a part of custom ps_trace.tag_map type which is a wrapper for
the built-in jsonb. It is the same as its jsonb_ namesake, but relies on tag_map_* functions.

__Function:__ ps_trace.tag_v_ne

__Schema:__ ps_trace
### _ps_trace.tag_v %= _ps_trace.tag_v → boolean
This operator is a part of custom ps_trace.tag_map type which is a wrapper for
the built-in jsonb. It is the same as its jsonb_ namesake, but relies on tag_map_* functions.

__Function:__ ps_trace.tag_v_eq

__Schema:__ ps_trace
### _ps_trace.tag_v %> _ps_trace.tag_v → boolean
This function is a part of custom _ps_trace.tag_v type which is a wrapper for the built-in jsonb. It is the same as its jsonb_ namesake.

__Function:__ tag_v_gt

__Schema:__ ps_trace
### _ps_trace.tag_v %>= _ps_trace.tag_v → boolean
This operator is a part of custom ps_trace.tag_map type which is a wrapper for
the built-in jsonb. It is the same as its jsonb_ namesake, but relies on tag_map_* functions.

__Function:__ tag_v_ge

__Schema:__ ps_trace
### tag_map -> text → _ps_trace.tag_v
This operator is a part of custom ps_trace.tag_map type which is a wrapper for
the built-in jsonb. It is the same as its jsonb_ namesake, but returns _ps_trace.tag_v.

__Function:__ tag_map_object_field

__Schema:__ ps_trace
### trace_id < trace_id → boolean
This function is a part of custom ps_trace.tag_traceid type which is a wrapper for the built-in uuid. It is the same as its uuid_ namesake.

__Function:__ _ps_trace.trace_id_lt

__Schema:__ ps_trace
### trace_id <= trace_id → boolean
This function is a part of custom ps_trace.tag_traceid type which is a wrapper for the built-in uuid. It is the same as its uuid_ namesake.

__Function:__ _ps_trace.trace_id_le

__Schema:__ ps_trace
### _ps_trace.tag_v <> jsonb → boolean
This operator is a part of custom ps_trace.tag_map type which is a wrapper for
the built-in jsonb. It is the same as its jsonb_ namesake, but relies on tag_map_* functions.

__Function:__ ps_trace.tag_v_ne

__Schema:__ ps_trace
### trace_id <> trace_id → boolean
This function is a part of custom ps_trace.tag_traceid type which is a wrapper for the built-in uuid. It is the same as its uuid_ namesake.

__Function:__ _ps_trace.trace_id_ne

__Schema:__ ps_trace
### _ps_trace.tag_v = jsonb → boolean
This operator is a part of custom ps_trace.tag_map type which is a wrapper for
the built-in jsonb. It is the same as its jsonb_ namesake, but relies on tag_map_* functions.

__Function:__ ps_trace.tag_v_eq

__Schema:__ ps_trace
### trace_id = trace_id → boolean
This function is a part of custom ps_trace.tag_traceid type which is a wrapper for the built-in uuid. It is the same as its uuid_ namesake.

__Function:__ _ps_trace.trace_id_eq

__Schema:__ ps_trace
### trace_id > trace_id → boolean
This function is a part of custom ps_trace.tag_traceid type which is a wrapper for the built-in uuid. It is the same as its uuid_ namesake.

__Function:__ _ps_trace.trace_id_gt

__Schema:__ ps_trace
### trace_id >= trace_id → boolean
This function is a part of custom ps_trace.tag_traceid type which is a wrapper for the built-in uuid. It is the same as its uuid_ namesake.

__Function:__ _ps_trace.trace_id_ge

__Schema:__ ps_trace
