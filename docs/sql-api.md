# SQL API
<!-- Note: This document is autogenerated. DO NOT EDIT. -->
## Functions
### prom_api.add_prom_node

```
procedure void **prom_api.add_prom_node**(IN node_name text, IN attach_to_existing_metrics boolean DEFAULT true)
```
### prom_api.config_maintenance_jobs
Configure the number of maintenance jobs run by the job scheduler, as well as their scheduled interval
```
function boolean **prom_api.config_maintenance_jobs**(number_jobs integer, new_schedule_interval interval, new_config jsonb DEFAULT NULL::jsonb)
```
### prom_api.drop_metric

```
function void **prom_api.drop_metric**(metric_name_to_be_dropped text)
```
### prom_api.eq
returns true if the labels and jsonb are equal, ignoring the metric name
```
function boolean **prom_api.eq**(labels label_array, json_labels jsonb)
```
### prom_api.eq
returns true if two label arrays are equal, ignoring the metric name
```
function boolean **prom_api.eq**(labels1 label_array, labels2 label_array)
```
### prom_api.eq
returns true if the label array and matchers are equal, there should not be a matcher for the metric name
```
function boolean **prom_api.eq**(labels1 label_array, matchers matcher_positive)
```
### prom_api.execute_maintenance
Execute maintenance tasks like dropping data according to retention policy. This procedure should be run regularly in a cron job
```
procedure void **prom_api.execute_maintenance**(IN log_verbose boolean DEFAULT false)
```
### prom_api.get_default_metric_retention_period
get the default retention period for all metrics
```
function interval **prom_api.get_default_metric_retention_period**()
```
### prom_api.get_metric_metadata

```
function TABLE(metric_family text, type text, unit text, help text) **prom_api.get_metric_metadata**(metric_family_name text)
```
### prom_api.get_metric_retention_period
get the retention period for a specific metric
```
function interval **prom_api.get_metric_retention_period**(metric_name text)
```
### prom_api.get_metric_retention_period
get the retention period for a specific metric
```
function interval **prom_api.get_metric_retention_period**(metric_schema text, metric_name text)
```
### prom_api.get_multiple_metric_metadata

```
function TABLE(metric_family text, type text, unit text, help text) **prom_api.get_multiple_metric_metadata**(metric_families text[])
```
### prom_api.is_normal_nan
returns true if the value is a NaN
```
function boolean **prom_api.is_normal_nan**(value double precision)
```
### prom_api.is_stale_marker
returns true if the value is a Prometheus stale marker
```
function boolean **prom_api.is_stale_marker**(value double precision)
```
### prom_api.jsonb
converts a labels array to a JSONB object
```
function jsonb **prom_api.jsonb**(labels label_array)
```
### prom_api.key_value_array
converts a labels array to two arrays: one for keys and another for values
```
function record **prom_api.key_value_array**(labels label_array, OUT keys text[], OUT vals text[])
```
### prom_api.label_cardinality

```
function integer **prom_api.label_cardinality**(label_id integer)
```
### prom_api.label_key_position

```
function integer **prom_api.label_key_position**(metric_name text, key text)
```
### prom_api.labels
fetches labels array for the given series id
```
function label_array **prom_api.labels**(series_id bigint)
```
### prom_api.labels_info
converts an array of label ids to three arrays: one for ids, one for keys and another for values
```
function record **prom_api.labels_info**(INOUT labels integer[], OUT keys text[], OUT vals text[])
```
### prom_api.matcher
returns a matcher for the JSONB, __name__ is ignored. The matcher can be used to match against a label array using @> or ? operators
```
function matcher_positive **prom_api.matcher**(labels jsonb)
```
### prom_api.promscale_post_restore
Performs required setup tasks after restoring the database from a logical backup
```
function void **prom_api.promscale_post_restore**()
```
### prom_api.register_metric_view

```
function boolean **prom_api.register_metric_view**(schema_name text, view_name text, if_not_exists boolean DEFAULT false)
```
### prom_api.reset_metric_chunk_interval
resets the chunk interval for a specific metric to using the default
```
function boolean **prom_api.reset_metric_chunk_interval**(metric_name text)
```
### prom_api.reset_metric_compression_setting
resets the compression setting for a specific metric to using the default
```
function boolean **prom_api.reset_metric_compression_setting**(metric_name text)
```
### prom_api.reset_metric_retention_period
resets the retention period for a specific raw metric in the default schema to using the default retention period
```
function boolean **prom_api.reset_metric_retention_period**(metric_name text)
```
### prom_api.reset_metric_retention_period
resets the retention period for a specific metric to using the default
```
function boolean **prom_api.reset_metric_retention_period**(schema_name text, metric_name text)
```
### prom_api.set_compression_on_metric_table
set a compression for a specific metric table
```
function void **prom_api.set_compression_on_metric_table**(metric_table_name text, compression_setting boolean)
```
### prom_api.set_default_chunk_interval
set the chunk interval for any metrics (existing and new) without an explicit override
```
function boolean **prom_api.set_default_chunk_interval**(chunk_interval interval)
```
### prom_api.set_default_compression_setting
set the compression setting for any metrics (existing and new) without an explicit override
```
function boolean **prom_api.set_default_compression_setting**(compression_setting boolean)
```
### prom_api.set_default_retention_period
set the retention period for any metrics (existing and new) without an explicit override
```
function boolean **prom_api.set_default_retention_period**(retention_period interval)
```
### prom_api.set_metric_chunk_interval
set a chunk interval for a specific metric (this overrides the default)
```
function boolean **prom_api.set_metric_chunk_interval**(metric_name text, chunk_interval interval)
```
### prom_api.set_metric_compression_setting
set a compression setting for a specific metric (this overrides the default)
```
function boolean **prom_api.set_metric_compression_setting**(metric_name text, new_compression_setting boolean)
```
### prom_api.set_metric_retention_period
set a retention period for a specific raw metric in default schema (this overrides the default)
```
function boolean **prom_api.set_metric_retention_period**(metric_name text, new_retention_period interval)
```
### prom_api.set_metric_retention_period
set a retention period for a specific metric (this overrides the default)
```
function boolean **prom_api.set_metric_retention_period**(schema_name text, metric_name text, new_retention_period interval)
```
### prom_api.unregister_metric_view

```
function boolean **prom_api.unregister_metric_view**(schema_name text, view_name text, if_exists boolean DEFAULT false)
```
### prom_api.val
returns the label value from a label id
```
function text **prom_api.val**(label_id integer)
```
### ps_tag.tag_op_equals
This function supports the == operator.
```
function tag_op_equals **ps_tag.tag_op_equals**(_tag_key text, _value anyelement)
```
### ps_tag.tag_op_equals_text
This function supports the == operator.
```
function tag_op_equals **ps_tag.tag_op_equals_text**(_tag_key text, _value text)
```
### ps_tag.tag_op_greater_than
This function supports the #> operator.
```
function tag_op_greater_than **ps_tag.tag_op_greater_than**(_tag_key text, _value anyelement)
```
### ps_tag.tag_op_greater_than_or_equal
This function supports the #>= operator.
```
function tag_op_greater_than_or_equal **ps_tag.tag_op_greater_than_or_equal**(_tag_key text, _value anyelement)
```
### ps_tag.tag_op_greater_than_or_equal_text
This function supports the #>= operator.
```
function tag_op_greater_than_or_equal **ps_tag.tag_op_greater_than_or_equal_text**(_tag_key text, _value text)
```
### ps_tag.tag_op_greater_than_text
This function supports the #> operator.
```
function tag_op_greater_than **ps_tag.tag_op_greater_than_text**(_tag_key text, _value text)
```
### ps_tag.tag_op_jsonb_path_exists
This function supports the @? operator.
```
function tag_op_jsonb_path_exists **ps_tag.tag_op_jsonb_path_exists**(_tag_key text, _value jsonpath)
```
### ps_tag.tag_op_less_than
This function supports the #< operator.
```
function tag_op_less_than **ps_tag.tag_op_less_than**(_tag_key text, _value anyelement)
```
### ps_tag.tag_op_less_than_or_equal
This function supports the #<= operator.
```
function tag_op_less_than_or_equal **ps_tag.tag_op_less_than_or_equal**(_tag_key text, _value anyelement)
```
### ps_tag.tag_op_less_than_or_equal_text
This function supports the #<= operator.
```
function tag_op_less_than_or_equal **ps_tag.tag_op_less_than_or_equal_text**(_tag_key text, _value text)
```
### ps_tag.tag_op_less_than_text
This function supports the #< operator.
```
function tag_op_less_than **ps_tag.tag_op_less_than_text**(_tag_key text, _value text)
```
### ps_tag.tag_op_not_equals
This function supports the !== operator.
```
function tag_op_not_equals **ps_tag.tag_op_not_equals**(_tag_key text, _value anyelement)
```
### ps_tag.tag_op_not_equals_text
This function supports the !== operator.
```
function tag_op_not_equals **ps_tag.tag_op_not_equals_text**(_tag_key text, _value text)
```
### ps_tag.tag_op_regexp_matches
This function supports the ==~ operator.
```
function tag_op_regexp_matches **ps_tag.tag_op_regexp_matches**(_tag_key text, _value text)
```
### ps_tag.tag_op_regexp_not_matches
This function supports the !=~ operator.
```
function tag_op_regexp_not_matches **ps_tag.tag_op_regexp_not_matches**(_tag_key text, _value text)
```
### ps_trace.delete_all_traces
WARNING: this function deletes all spans and related tracing data in the system and restores it to a "just installed" state.
```
function void **ps_trace.delete_all_traces**()
```
### ps_trace.downstream_spans

```
function TABLE(trace_id trace_id, parent_span_id bigint, span_id bigint, dist integer, path bigint[]) **ps_trace.downstream_spans**(_trace_id trace_id, _span_id bigint, _max_dist integer DEFAULT NULL::integer)
```
### ps_trace.event_tag_type

```
function tag_type **ps_trace.event_tag_type**()
```
### ps_trace.get_tag_map

```
function tag_map **ps_trace.get_tag_map**(_tags jsonb)
```
### ps_trace.get_trace_retention_period
get the retention period for trace data
```
function interval **ps_trace.get_trace_retention_period**()
```
### ps_trace.is_event_tag_type

```
function boolean **ps_trace.is_event_tag_type**(_tag_type tag_type)
```
### ps_trace.is_link_tag_type

```
function boolean **ps_trace.is_link_tag_type**(_tag_type tag_type)
```
### ps_trace.is_resource_tag_type

```
function boolean **ps_trace.is_resource_tag_type**(_tag_type tag_type)
```
### ps_trace.is_span_tag_type

```
function boolean **ps_trace.is_span_tag_type**(_tag_type tag_type)
```
### ps_trace.link_tag_type

```
function tag_type **ps_trace.link_tag_type**()
```
### ps_trace.operation_calls

```
function TABLE(parent_operation_id bigint, child_operation_id bigint, cnt bigint) **ps_trace.operation_calls**(_start_time_min timestamp with time zone, _start_time_max timestamp with time zone)
```
### ps_trace.put_instrumentation_lib

```
function bigint **ps_trace.put_instrumentation_lib**(_name text, _version text, _schema_url_id bigint)
```
### ps_trace.put_operation

```
function bigint **ps_trace.put_operation**(_service_name text, _span_name text, _span_kind span_kind)
```
### ps_trace.put_schema_url

```
function bigint **ps_trace.put_schema_url**(_schema_url text)
```
### ps_trace.put_tag

```
function bigint **ps_trace.put_tag**(_key tag_k, _value _ps_trace.tag_v, _tag_type tag_type)
```
### ps_trace.put_tag_key

```
function bigint **ps_trace.put_tag_key**(_key tag_k, _tag_type tag_type)
```
### ps_trace.resource_tag_type

```
function tag_type **ps_trace.resource_tag_type**()
```
### ps_trace.set_trace_retention_period
set the retention period for trace data
```
function boolean **ps_trace.set_trace_retention_period**(_trace_retention_period interval)
```
### ps_trace.sibling_spans

```
function TABLE(trace_id trace_id, parent_span_id bigint, span_id bigint) **ps_trace.sibling_spans**(_trace_id trace_id, _span_id bigint)
```
### ps_trace.span_tag_type

```
function tag_type **ps_trace.span_tag_type**()
```
### ps_trace.span_tree

```
function TABLE(trace_id trace_id, parent_span_id bigint, span_id bigint, dist integer, is_upstream boolean, is_downstream boolean, path bigint[]) **ps_trace.span_tree**(_trace_id trace_id, _span_id bigint, _max_dist integer DEFAULT NULL::integer)
```
### ps_trace.tag_map_in

```
function tag_map **ps_trace.tag_map_in**(cstring)
```
### ps_trace.tag_map_object_field

```
function _ps_trace.tag_v **ps_trace.tag_map_object_field**(tag_map, text)
```
### ps_trace.tag_map_out

```
function cstring **ps_trace.tag_map_out**(tag_map)
```
### ps_trace.tag_map_recv

```
function tag_map **ps_trace.tag_map_recv**(internal)
```
### ps_trace.tag_map_send

```
function bytea **ps_trace.tag_map_send**(tag_map)
```
### ps_trace.tag_map_subscript_handler

```
function internal **ps_trace.tag_map_subscript_handler**(internal)
```
### ps_trace.tag_v_eq

```
function boolean **ps_trace.tag_v_eq**(_ps_trace.tag_v, _ps_trace.tag_v)
```
### ps_trace.tag_v_eq

```
function boolean **ps_trace.tag_v_eq**(_ps_trace.tag_v, jsonb)
```
### ps_trace.tag_v_ge

```
function boolean **ps_trace.tag_v_ge**(_ps_trace.tag_v, _ps_trace.tag_v)
```
### ps_trace.tag_v_gt

```
function boolean **ps_trace.tag_v_gt**(_ps_trace.tag_v, _ps_trace.tag_v)
```
### ps_trace.tag_v_le

```
function boolean **ps_trace.tag_v_le**(_ps_trace.tag_v, _ps_trace.tag_v)
```
### ps_trace.tag_v_lt

```
function boolean **ps_trace.tag_v_lt**(_ps_trace.tag_v, _ps_trace.tag_v)
```
### ps_trace.tag_v_ne

```
function boolean **ps_trace.tag_v_ne**(_ps_trace.tag_v, _ps_trace.tag_v)
```
### ps_trace.tag_v_ne

```
function boolean **ps_trace.tag_v_ne**(_ps_trace.tag_v, jsonb)
```
### ps_trace.trace_tree

```
function TABLE(trace_id trace_id, parent_span_id bigint, span_id bigint, lvl integer, path bigint[]) **ps_trace.trace_tree**(_trace_id trace_id)
```
### ps_trace.upstream_spans

```
function TABLE(trace_id trace_id, parent_span_id bigint, span_id bigint, dist integer, path bigint[]) **ps_trace.upstream_spans**(_trace_id trace_id, _span_id bigint, _max_dist integer DEFAULT NULL::integer)
```
### _prom_catalog.attach_series_partition

```
function void **_prom_catalog.attach_series_partition**(metric_record _prom_catalog.metric)
```
### _prom_catalog.compress_chunk_for_hypertable

```
function void **_prom_catalog.compress_chunk_for_hypertable**(_hypertable_schema_name text, _hypertable_table_name text, _chunk_schema_name text, _chunk_table_name text)
```
### _prom_catalog.compress_metric_chunks

```
procedure void **_prom_catalog.compress_metric_chunks**(IN metric_name text)
```
### _prom_catalog.compress_old_chunks

```
procedure void **_prom_catalog.compress_old_chunks**(IN _hypertable_schema_name text, IN _hypertable_table_name text, IN _compress_before timestamp with time zone)
```
### _prom_catalog.count_jsonb_keys

```
function integer **_prom_catalog.count_jsonb_keys**(j jsonb)
```
### _prom_catalog.create_exemplar_table_if_not_exists

```
function boolean **_prom_catalog.create_exemplar_table_if_not_exists**(metric_name text)
```
### _prom_catalog.create_label_key

```
function record **_prom_catalog.create_label_key**(new_key text, OUT id integer, OUT value_column_name name, OUT id_column_name name)
```
### _prom_catalog.create_metric_table

```
function record **_prom_catalog.create_metric_table**(metric_name_arg text, OUT id integer, OUT table_name name)
```
### _prom_catalog.create_metric_view

```
function boolean **_prom_catalog.create_metric_view**(metric_name text)
```
### _prom_catalog.create_series

```
function bigint **_prom_catalog.create_series**(metric_id integer, metric_table_name text, label_array label_array, OUT series_id bigint)
```
### _prom_catalog.create_series_view

```
function boolean **_prom_catalog.create_series_view**(metric_name text)
```
### _prom_catalog.decompress_chunk_for_metric

```
function void **_prom_catalog.decompress_chunk_for_metric**(metric_table text, chunk_schema_name text, chunk_table_name text)
```
### _prom_catalog.decompress_chunks_after

```
procedure void **_prom_catalog.decompress_chunks_after**(IN metric_table text, IN min_time timestamp with time zone, IN transactional boolean DEFAULT false)
```
### _prom_catalog.delay_compression_job

```
function void **_prom_catalog.delay_compression_job**(ht_table text, new_start timestamp with time zone)
```
### _prom_catalog.delete_expired_series

```
function void **_prom_catalog.delete_expired_series**(metric_schema text, metric_table text, metric_series_table text, ran_at timestamp with time zone, present_epoch bigint, last_updated_epoch timestamp with time zone)
```
### _prom_catalog.delete_series_catalog_row

```
function void **_prom_catalog.delete_series_catalog_row**(metric_table text, series_ids bigint[])
```
### _prom_catalog.delete_series_from_metric

```
function bigint **_prom_catalog.delete_series_from_metric**(name text, series_ids bigint[])
```
### _prom_catalog.do_decompress_chunks_after

```
procedure void **_prom_catalog.do_decompress_chunks_after**(IN metric_table text, IN min_time timestamp with time zone, IN transactional boolean DEFAULT false)
```
### _prom_catalog.drop_metric_chunk_data

```
function void **_prom_catalog.drop_metric_chunk_data**(schema_name text, metric_name text, older_than timestamp with time zone)
```
### _prom_catalog.drop_metric_chunks

```
procedure void **_prom_catalog.drop_metric_chunks**(IN schema_name text, IN metric_name text, IN older_than timestamp with time zone, IN ran_at timestamp with time zone DEFAULT now(), IN log_verbose boolean DEFAULT false)
```
### _prom_catalog.epoch_abort
ABORT an INSERT transaction due to the ID epoch being out of date
```
function void **_prom_catalog.epoch_abort**(user_epoch bigint)
```
### _prom_catalog.execute_compression_policy
compress data according to the policy. This procedure should be run regularly in a cron job
```
procedure void **_prom_catalog.execute_compression_policy**(IN log_verbose boolean DEFAULT false)
```
### _prom_catalog.execute_data_retention_policy
drops old data according to the data retention policy. This procedure should be run regularly in a cron job
```
procedure void **_prom_catalog.execute_data_retention_policy**(IN log_verbose boolean)
```
### _prom_catalog.execute_everywhere

```
procedure void **_prom_catalog.execute_everywhere**(IN command_key text, IN command text, IN transactional boolean DEFAULT true)
```
### _prom_catalog.execute_maintenance_job

```
procedure void **_prom_catalog.execute_maintenance_job**(IN job_id integer, IN config jsonb)
```
### _prom_catalog.finalize_metric_creation
Finalizes metric creation. This procedure should be run by the connector automatically
```
procedure void **_prom_catalog.finalize_metric_creation**()
```
### _prom_catalog.get_advisory_lock_prefix_job

```
function integer **_prom_catalog.get_advisory_lock_prefix_job**()
```
### _prom_catalog.get_advisory_lock_prefix_maintenance

```
function integer **_prom_catalog.get_advisory_lock_prefix_maintenance**()
```
### _prom_catalog.get_cagg_info

```
function record **_prom_catalog.get_cagg_info**(metric_schema text, metric_table text, OUT is_cagg boolean, OUT cagg_schema name, OUT cagg_name name, OUT metric_table_name name, OUT materialized_hypertable_id integer, OUT storage_hypertable_relation text)
```
### _prom_catalog.get_confirmed_unused_series

```
function bigint[] **_prom_catalog.get_confirmed_unused_series**(metric_schema text, metric_table text, series_table text, potential_series_ids bigint[], check_time timestamp with time zone)
```
### _prom_catalog.get_default_chunk_interval

```
function interval **_prom_catalog.get_default_chunk_interval**()
```
### _prom_catalog.get_default_compression_setting

```
function boolean **_prom_catalog.get_default_compression_setting**()
```
### _prom_catalog.get_default_retention_period

```
function interval **_prom_catalog.get_default_retention_period**()
```
### _prom_catalog.get_default_value

```
function text **_prom_catalog.get_default_value**(_key text)
```
### _prom_catalog.get_exemplar_label_key_positions

```
function json **_prom_catalog.get_exemplar_label_key_positions**(metric_name text)
```
### _prom_catalog.get_first_level_view_on_metric

```
function TABLE(view_schema name, view_name name, metric_table_name name) **_prom_catalog.get_first_level_view_on_metric**(metric_schema text, metric_table text)
```
### _prom_catalog.get_label_key_column_name_for_view

```
function name **_prom_catalog.get_label_key_column_name_for_view**(label_key text, id boolean)
```
### _prom_catalog.get_metric_compression_setting

```
function boolean **_prom_catalog.get_metric_compression_setting**(metric_name text)
```
### _prom_catalog.get_metric_retention_period

```
function interval **_prom_catalog.get_metric_retention_period**(metric_name text)
```
### _prom_catalog.get_metric_retention_period

```
function interval **_prom_catalog.get_metric_retention_period**(schema_name text, metric_name text)
```
### _prom_catalog.get_metric_table_name_if_exists

```
function TABLE(id integer, table_name name, table_schema name, series_table name, is_view boolean) **_prom_catalog.get_metric_table_name_if_exists**(schema text, metric_name text)
```
### _prom_catalog.get_metrics_that_need_compression

```
function SETOF _prom_catalog.metric **_prom_catalog.get_metrics_that_need_compression**()
```
### _prom_catalog.get_metrics_that_need_drop_chunk

```
function SETOF _prom_catalog.metric **_prom_catalog.get_metrics_that_need_drop_chunk**()
```
### _prom_catalog.get_new_label_id

```
function integer **_prom_catalog.get_new_label_id**(key_name text, value_name text, OUT id integer)
```
### _prom_catalog.get_new_pos_for_key

```
function integer[] **_prom_catalog.get_new_pos_for_key**(metric_name text, metric_table text, key_name_array text[], is_for_exemplar boolean)
```
### _prom_catalog.get_or_create_label_array
converts a jsonb to a label array
```
function label_array **_prom_catalog.get_or_create_label_array**(js jsonb)
```
### _prom_catalog.get_or_create_label_array
converts a metric name, array of keys, and array of values to a label array
```
function label_array **_prom_catalog.get_or_create_label_array**(metric_name text, label_keys text[], label_values text[])
```
### _prom_catalog.get_or_create_label_id

```
function integer **_prom_catalog.get_or_create_label_id**(key_name text, value_name text)
```
### _prom_catalog.get_or_create_label_ids
converts a metric name, array of keys, and array of values to a list of label ids
```
function TABLE(pos integer[], id integer[], label_key text[], label_value text[]) **_prom_catalog.get_or_create_label_ids**(metric_name text, metric_table text, label_keys text[], label_values text[])
```
### _prom_catalog.get_or_create_label_key

```
function record **_prom_catalog.get_or_create_label_key**(key text, OUT id integer, OUT value_column_name name, OUT id_column_name name)
```
### _prom_catalog.get_or_create_label_key_pos

```
function integer **_prom_catalog.get_or_create_label_key_pos**(metric_name text, key text)
```
### _prom_catalog.get_or_create_metric_table_name

```
function record **_prom_catalog.get_or_create_metric_table_name**(metric_name text, OUT id integer, OUT table_name name, OUT possibly_new boolean)
```
### _prom_catalog.get_or_create_series_id
returns the series id that exactly matches a JSONB of labels
```
function bigint **_prom_catalog.get_or_create_series_id**(label jsonb)
```
### _prom_catalog.get_or_create_series_id_for_kv_array

```
function record **_prom_catalog.get_or_create_series_id_for_kv_array**(metric_name text, label_keys text[], label_values text[], OUT table_name name, OUT series_id bigint)
```
### _prom_catalog.get_or_create_series_id_for_label_array

```
function bigint **_prom_catalog.get_or_create_series_id_for_label_array**(metric_id integer, table_name text, larray label_array, OUT series_id bigint)
```
### _prom_catalog.get_staggered_chunk_interval

```
function interval **_prom_catalog.get_staggered_chunk_interval**(chunk_interval interval)
```
### _prom_catalog.get_storage_hypertable_info

```
function TABLE(id integer, hypertable_relation text) **_prom_catalog.get_storage_hypertable_info**(metric_schema_name text, metric_table_name text, is_view boolean)
```
### _prom_catalog.get_timescale_major_version

```
function integer **_prom_catalog.get_timescale_major_version**()
```
### _prom_catalog.get_timescale_minor_version

```
function integer **_prom_catalog.get_timescale_minor_version**()
```
### _prom_catalog.ha_leases_audit_fn

```
function trigger **_prom_catalog.ha_leases_audit_fn**()
```
### _prom_catalog.hypertable_compression_stats_for_schema

```
function TABLE(hypertable_name text, total_chunks bigint, number_compressed_chunks bigint, before_compression_total_bytes bigint, after_compression_total_bytes bigint) **_prom_catalog.hypertable_compression_stats_for_schema**(schema_name_in text)
```
### _prom_catalog.hypertable_local_size

```
function TABLE(hypertable_name text, table_bytes bigint, index_bytes bigint, toast_bytes bigint, total_bytes bigint) **_prom_catalog.hypertable_local_size**(schema_name_in text)
```
### _prom_catalog.hypertable_node_up

```
function TABLE(hypertable_name text, node_name text, node_up boolean) **_prom_catalog.hypertable_node_up**(schema_name_in text)
```
### _prom_catalog.hypertable_remote_size

```
function TABLE(hypertable_name text, table_bytes bigint, index_bytes bigint, toast_bytes bigint, total_bytes bigint) **_prom_catalog.hypertable_remote_size**(schema_name_in text)
```
### _prom_catalog.insert_exemplar_row

```
function bigint **_prom_catalog.insert_exemplar_row**(metric_table text, time_array timestamp with time zone[], series_id_array bigint[], exemplar_label_values_array label_value_array[], value_array double precision[])
```
### _prom_catalog.insert_metric_metadatas

```
function bigint **_prom_catalog.insert_metric_metadatas**(t timestamp with time zone[], metric_family_name text[], metric_type text[], metric_unit text[], metric_help text[])
```
### _prom_catalog.insert_metric_row

```
function bigint **_prom_catalog.insert_metric_row**(metric_table text, time_array timestamp with time zone[], value_array double precision[], series_id_array bigint[])
```
### _prom_catalog.is_multinode

```
function boolean **_prom_catalog.is_multinode**()
```
### _prom_catalog.is_restore_in_progress

```
function boolean **_prom_catalog.is_restore_in_progress**()
```
### _prom_catalog.is_timescaledb_installed

```
function boolean **_prom_catalog.is_timescaledb_installed**()
```
### _prom_catalog.is_timescaledb_oss

```
function boolean **_prom_catalog.is_timescaledb_oss**()
```
### _prom_catalog.label_contains

```
function boolean **_prom_catalog.label_contains**(labels label_array, json_labels jsonb)
```
### _prom_catalog.label_find_key_equal

```
function matcher_positive **_prom_catalog.label_find_key_equal**(key_to_match label_key, pat pattern)
```
### _prom_catalog.label_find_key_not_equal

```
function matcher_negative **_prom_catalog.label_find_key_not_equal**(key_to_match label_key, pat pattern)
```
### _prom_catalog.label_find_key_not_regex

```
function matcher_negative **_prom_catalog.label_find_key_not_regex**(key_to_match label_key, pat pattern)
```
### _prom_catalog.label_find_key_regex

```
function matcher_positive **_prom_catalog.label_find_key_regex**(key_to_match label_key, pat pattern)
```
### _prom_catalog.label_jsonb_each_text

```
function SETOF record **_prom_catalog.label_jsonb_each_text**(js jsonb, OUT key text, OUT value text)
```
### _prom_catalog.label_match

```
function boolean **_prom_catalog.label_match**(labels label_array, matchers matcher_negative)
```
### _prom_catalog.label_match

```
function boolean **_prom_catalog.label_match**(labels label_array, matchers matcher_positive)
```
### _prom_catalog.label_unnest

```
function SETOF anyelement **_prom_catalog.label_unnest**(label_array anyarray)
```
### _prom_catalog.label_value_contains

```
function boolean **_prom_catalog.label_value_contains**(labels label_value_array, label_value text)
```
### _prom_catalog.lock_metric_for_maintenance

```
function boolean **_prom_catalog.lock_metric_for_maintenance**(metric_id integer, wait boolean DEFAULT true)
```
### _prom_catalog.make_metric_table

```
function trigger **_prom_catalog.make_metric_table**()
```
### _prom_catalog.mark_unused_series

```
function void **_prom_catalog.mark_unused_series**(metric_schema text, metric_table text, metric_series_table text, older_than timestamp with time zone, check_time timestamp with time zone)
```
### _prom_catalog.match_equals

```
function boolean **_prom_catalog.match_equals**(labels label_array, _op tag_op_equals)
```
### _prom_catalog.match_not_equals

```
function boolean **_prom_catalog.match_not_equals**(labels label_array, _op tag_op_not_equals)
```
### _prom_catalog.match_regexp_matches

```
function boolean **_prom_catalog.match_regexp_matches**(labels label_array, _op tag_op_regexp_matches)
```
### _prom_catalog.match_regexp_not_matches

```
function boolean **_prom_catalog.match_regexp_not_matches**(labels label_array, _op tag_op_regexp_not_matches)
```
### _prom_catalog.metric_view

```
function TABLE(id integer, metric_name text, table_name text, label_keys text[], retention_period interval, chunk_interval interval, compressed_interval interval, total_interval interval, before_compression_bytes bigint, after_compression_bytes bigint, total_size_bytes bigint, total_size text, compression_ratio numeric, total_chunks bigint, compressed_chunks bigint) **_prom_catalog.metric_view**()
```
### _prom_catalog.pg_name_unique

```
function name **_prom_catalog.pg_name_unique**(full_name_arg text, suffix text)
```
### _prom_catalog.pg_name_with_suffix

```
function name **_prom_catalog.pg_name_with_suffix**(full_name text, suffix text)
```
### _prom_catalog.resurrect_series_ids

```
function void **_prom_catalog.resurrect_series_ids**(metric_table text, series_id bigint)
```
### _prom_catalog.safe_approximate_row_count

```
function bigint **_prom_catalog.safe_approximate_row_count**(table_name_input regclass)
```
### _prom_catalog.set_app_name

```
function void **_prom_catalog.set_app_name**(full_name text)
```
### _prom_catalog.set_chunk_interval_on_metric_table

```
function void **_prom_catalog.set_chunk_interval_on_metric_table**(metric_name text, new_interval interval)
```
### _prom_catalog.set_default_value

```
function void **_prom_catalog.set_default_value**(_key text, _value text)
```
### _prom_catalog.try_change_leader

```
function _prom_catalog.ha_leases **_prom_catalog.try_change_leader**(cluster text, new_leader text, max_time timestamp with time zone)
```
### _prom_catalog.unlock_metric_for_maintenance

```
function void **_prom_catalog.unlock_metric_for_maintenance**(metric_id integer)
```
### _prom_catalog.update_execute_everywhere_entry

```
procedure void **_prom_catalog.update_execute_everywhere_entry**(IN command_key text, IN command text, IN transactional boolean DEFAULT true)
```
### _prom_catalog.update_lease

```
function _prom_catalog.ha_leases **_prom_catalog.update_lease**(cluster text, writer text, min_time timestamp with time zone, max_time timestamp with time zone)
```
### _prom_ext.gapfilldeltatransition_in

```
function _prom_ext.gapfilldeltatransition **_prom_ext.gapfilldeltatransition_in**(input cstring)
```
### _prom_ext.gapfilldeltatransition_out

```
function cstring **_prom_ext.gapfilldeltatransition_out**(input _prom_ext.gapfilldeltatransition)
```
### _prom_ext.jsonb_digest

```
function bytea **_prom_ext.jsonb_digest**(jsonb jsonb)
```
### _prom_ext.num_cpus

```
function integer **_prom_ext.num_cpus**()
```
### _prom_ext.prom_delta

```
aggregate double precision[] **_prom_ext.prom_delta**(lowest_time timestamp with time zone, greatest_time timestamp with time zone, step_size bigint, range bigint, sample_time timestamp with time zone, sample_value double precision)
```
### _prom_ext.prom_delta_transition

```
function internal **_prom_ext.prom_delta_transition**(state internal, lowest_time timestamp with time zone, greatest_time timestamp with time zone, step_size bigint, range bigint, sample_time timestamp with time zone, sample_value double precision)
```
### _prom_ext.prom_extrapolate_final

```
function double precision[] **_prom_ext.prom_extrapolate_final**(state internal)
```
### _prom_ext.prom_increase

```
aggregate double precision[] **_prom_ext.prom_increase**(lowest_time timestamp with time zone, greatest_time timestamp with time zone, step_size bigint, range bigint, sample_time timestamp with time zone, sample_value double precision)
```
### _prom_ext.prom_increase_transition

```
function internal **_prom_ext.prom_increase_transition**(state internal, lowest_time timestamp with time zone, greatest_time timestamp with time zone, step_size bigint, range bigint, sample_time timestamp with time zone, sample_value double precision)
```
### _prom_ext.prom_rate

```
aggregate double precision[] **_prom_ext.prom_rate**(lowest_time timestamp with time zone, greatest_time timestamp with time zone, step_size bigint, range bigint, sample_time timestamp with time zone, sample_value double precision)
```
### _prom_ext.prom_rate_transition

```
function internal **_prom_ext.prom_rate_transition**(state internal, lowest_time timestamp with time zone, greatest_time timestamp with time zone, step_size bigint, range bigint, sample_time timestamp with time zone, sample_value double precision)
```
### _prom_ext.rewrite_fn_call_to_subquery

```
function internal **_prom_ext.rewrite_fn_call_to_subquery**(input internal)
```
### _prom_ext.tag_map_rewrite

```
function internal **_prom_ext.tag_map_rewrite**(input internal)
```
### _prom_ext.update_tsprom_metadata

```
function void **_prom_ext.update_tsprom_metadata**(meta_key text, meta_value text, send_telemetry boolean)
```
### _prom_ext.vector_selector

```
aggregate double precision[] **_prom_ext.vector_selector**(start_time timestamp with time zone, end_time timestamp with time zone, bucket_width bigint, lookback bigint, sample_time timestamp with time zone, sample_value double precision)
```
### _prom_ext.vector_selector_combine

```
function internal **_prom_ext.vector_selector_combine**(state1 internal, state2 internal)
```
### _prom_ext.vector_selector_deserialize

```
function internal **_prom_ext.vector_selector_deserialize**(bytes bytea, _internal internal)
```
### _prom_ext.vector_selector_final

```
function double precision[] **_prom_ext.vector_selector_final**(state internal)
```
### _prom_ext.vector_selector_serialize

```
function bytea **_prom_ext.vector_selector_serialize**(state internal)
```
### _prom_ext.vector_selector_transition

```
function internal **_prom_ext.vector_selector_transition**(state internal, start_time timestamp with time zone, end_time timestamp with time zone, bucket_width bigint, lookback bigint, "time" timestamp with time zone, value double precision)
```
### _ps_catalog.apply_telemetry

```
function void **_ps_catalog.apply_telemetry**(telemetry_name text, telemetry_value text)
```
### _ps_catalog.promscale_sql_telemetry

```
function void **_ps_catalog.promscale_sql_telemetry**()
```
### _ps_catalog.promscale_telemetry_housekeeping

```
function boolean **_ps_catalog.promscale_telemetry_housekeeping**(telemetry_sync_duration interval DEFAULT '01:00:00'::interval)
```
### _ps_trace.drop_event_chunks

```
procedure void **_ps_trace.drop_event_chunks**(IN _older_than timestamp with time zone)
```
### _ps_trace.drop_link_chunks

```
procedure void **_ps_trace.drop_link_chunks**(IN _older_than timestamp with time zone)
```
### _ps_trace.drop_span_chunks

```
procedure void **_ps_trace.drop_span_chunks**(IN _older_than timestamp with time zone)
```
### _ps_trace.ensure_trace_ingest_temp_table

```
function void **_ps_trace.ensure_trace_ingest_temp_table**(_temp_table_name text, _proto_table_name text)
```
### _ps_trace.execute_data_retention_policy
drops old data according to the data retention policy. This procedure should be run regularly in a cron job
```
procedure void **_ps_trace.execute_data_retention_policy**(IN log_verbose boolean)
```
### _ps_trace.execute_tracing_compression
Execute tracing compression compresses tracing tables
```
procedure void **_ps_trace.execute_tracing_compression**(IN hypertable_name text, IN log_verbose boolean DEFAULT false)
```
### _ps_trace.execute_tracing_compression_job

```
procedure void **_ps_trace.execute_tracing_compression_job**(IN job_id integer, IN config jsonb)
```
### _ps_trace.tag_map_denormalize

```
function tag_map **_ps_trace.tag_map_denormalize**(_map tag_map)
```
### _ps_trace.tag_v_cmp

```
function integer **_ps_trace.tag_v_cmp**(_ps_trace.tag_v, _ps_trace.tag_v)
```
### _ps_trace.tag_v_eq_matching_tags

```
function jsonb **_ps_trace.tag_v_eq_matching_tags**(_tag_key text, _value jsonb)
```
### _ps_trace.tag_v_in

```
function _ps_trace.tag_v **_ps_trace.tag_v_in**(cstring)
```
### _ps_trace.tag_v_ne_matching_tags

```
function jsonb[] **_ps_trace.tag_v_ne_matching_tags**(_tag_key text, _value jsonb)
```
### _ps_trace.tag_v_out

```
function cstring **_ps_trace.tag_v_out**(_ps_trace.tag_v)
```
### _ps_trace.tag_v_recv

```
function _ps_trace.tag_v **_ps_trace.tag_v_recv**(internal)
```
### _ps_trace.tag_v_send

```
function bytea **_ps_trace.tag_v_send**(_ps_trace.tag_v)
```
### _ps_trace.tag_v_subscript_handler

```
function internal **_ps_trace.tag_v_subscript_handler**(internal)
```
### _ps_trace.trace_id_cmp

```
function integer **_ps_trace.trace_id_cmp**(trace_id, trace_id)
```
### _ps_trace.trace_id_eq

```
function boolean **_ps_trace.trace_id_eq**(trace_id, trace_id)
```
### _ps_trace.trace_id_ge

```
function boolean **_ps_trace.trace_id_ge**(trace_id, trace_id)
```
### _ps_trace.trace_id_gt

```
function boolean **_ps_trace.trace_id_gt**(trace_id, trace_id)
```
### _ps_trace.trace_id_hash

```
function integer **_ps_trace.trace_id_hash**(trace_id)
```
### _ps_trace.trace_id_in

```
function trace_id **_ps_trace.trace_id_in**(cstring)
```
### _ps_trace.trace_id_le

```
function boolean **_ps_trace.trace_id_le**(trace_id, trace_id)
```
### _ps_trace.trace_id_lt

```
function boolean **_ps_trace.trace_id_lt**(trace_id, trace_id)
```
### _ps_trace.trace_id_ne

```
function boolean **_ps_trace.trace_id_ne**(trace_id, trace_id)
```
### _ps_trace.trace_id_out

```
function cstring **_ps_trace.trace_id_out**(trace_id)
```
### _ps_trace.trace_id_recv

```
function trace_id **_ps_trace.trace_id_recv**(internal)
```
### _ps_trace.trace_id_send

```
function bytea **_ps_trace.trace_id_send**(trace_id)
```
## Operators
### label_array ? matcher_negative → boolean


__Function:__ _prom_catalog.label_match

__Schema:__ prom_api
### label_array ? matcher_positive → boolean


__Function:__ _prom_catalog.label_match

__Schema:__ prom_api
### label_array ? tag_op_equals → boolean


__Function:__ _prom_catalog.match_equals

__Schema:__ prom_api
### label_array ? tag_op_not_equals → boolean


__Function:__ _prom_catalog.match_not_equals

__Schema:__ prom_api
### label_array ? tag_op_regexp_matches → boolean


__Function:__ _prom_catalog.match_regexp_matches

__Schema:__ prom_api
### label_array ? tag_op_regexp_not_matches → boolean


__Function:__ _prom_catalog.match_regexp_not_matches

__Schema:__ prom_api
### label_array @> jsonb → boolean


__Function:__ _prom_catalog.label_contains

__Schema:__ prom_api
### label_value_array @> text → boolean


__Function:__ _prom_catalog.label_value_contains

__Schema:__ prom_api
### text !== anyelement → tag_op_not_equals
This function supports the !== operator.

__Function:__ tag_op_not_equals

__Schema:__ ps_tag
### text !== text → tag_op_not_equals
This function supports the !== operator.

__Function:__ tag_op_not_equals_text

__Schema:__ ps_tag
### text !=~ text → tag_op_regexp_not_matches
This function supports the !=~ operator.

__Function:__ tag_op_regexp_not_matches

__Schema:__ ps_tag
### text #< anyelement → tag_op_less_than
This function supports the #< operator.

__Function:__ tag_op_less_than

__Schema:__ ps_tag
### text #< text → tag_op_less_than
This function supports the #< operator.

__Function:__ tag_op_less_than_text

__Schema:__ ps_tag
### text #<= anyelement → tag_op_less_than_or_equal
This function supports the #<= operator.

__Function:__ tag_op_less_than_or_equal

__Schema:__ ps_tag
### text #<= text → tag_op_less_than_or_equal
This function supports the #<= operator.

__Function:__ tag_op_less_than_or_equal_text

__Schema:__ ps_tag
### text #> anyelement → tag_op_greater_than
This function supports the #> operator.

__Function:__ tag_op_greater_than

__Schema:__ ps_tag
### text #> text → tag_op_greater_than
This function supports the #> operator.

__Function:__ tag_op_greater_than_text

__Schema:__ ps_tag
### text #>= anyelement → tag_op_greater_than_or_equal
This function supports the #>= operator.

__Function:__ tag_op_greater_than_or_equal

__Schema:__ ps_tag
### text #>= text → tag_op_greater_than_or_equal
This function supports the #>= operator.

__Function:__ tag_op_greater_than_or_equal_text

__Schema:__ ps_tag
### text == anyelement → tag_op_equals
This function supports the == operator.

__Function:__ tag_op_equals

__Schema:__ ps_tag
### text == text → tag_op_equals
This function supports the == operator.

__Function:__ tag_op_equals_text

__Schema:__ ps_tag
### text ==~ text → tag_op_regexp_matches
This function supports the ==~ operator.

__Function:__ tag_op_regexp_matches

__Schema:__ ps_tag
### text @? jsonpath → tag_op_jsonb_path_exists
This function supports the @? operator.

__Function:__ tag_op_jsonb_path_exists

__Schema:__ ps_tag
### tag_map -> text → _ps_trace.tag_v


__Function:__ tag_map_object_field

__Schema:__ ps_trace
### _ps_trace.tag_v < _ps_trace.tag_v → boolean


__Function:__ tag_v_lt

__Schema:__ ps_trace
### trace_id < trace_id → boolean


__Function:__ _ps_trace.trace_id_lt

__Schema:__ ps_trace
### _ps_trace.tag_v <= _ps_trace.tag_v → boolean


__Function:__ tag_v_le

__Schema:__ ps_trace
### trace_id <= trace_id → boolean


__Function:__ _ps_trace.trace_id_le

__Schema:__ ps_trace
### _ps_trace.tag_v <> _ps_trace.tag_v → boolean


__Function:__ ps_trace.tag_v_ne

__Schema:__ ps_trace
### _ps_trace.tag_v <> jsonb → boolean


__Function:__ ps_trace.tag_v_ne

__Schema:__ ps_trace
### trace_id <> trace_id → boolean


__Function:__ _ps_trace.trace_id_ne

__Schema:__ ps_trace
### _ps_trace.tag_v = _ps_trace.tag_v → boolean


__Function:__ ps_trace.tag_v_eq

__Schema:__ ps_trace
### _ps_trace.tag_v = jsonb → boolean


__Function:__ ps_trace.tag_v_eq

__Schema:__ ps_trace
### trace_id = trace_id → boolean


__Function:__ _ps_trace.trace_id_eq

__Schema:__ ps_trace
### _ps_trace.tag_v > _ps_trace.tag_v → boolean


__Function:__ tag_v_gt

__Schema:__ ps_trace
### trace_id > trace_id → boolean


__Function:__ _ps_trace.trace_id_gt

__Schema:__ ps_trace
### _ps_trace.tag_v >= _ps_trace.tag_v → boolean


__Function:__ tag_v_ge

__Schema:__ ps_trace
### trace_id >= trace_id → boolean


__Function:__ _ps_trace.trace_id_ge

__Schema:__ ps_trace
